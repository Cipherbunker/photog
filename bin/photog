#!/usr/bin/perl
use warnings;
use strict;
use feature 'say';
use Photography::Website;
use Cwd;
use File::Spec::Functions         qw(catfile);
use File::Basename                qw(basename dirname);
use File::ShareDir                qw(dist_file);
use File::Path                    qw(make_path);
use Config::General               qw(ParseConfig);
use String::Random                qw(random_regex);
use Algorithm::Numerical::Shuffle qw(shuffle);
use Array::Utils                  qw(array_minus);
use Template; my $tt = Template->new({ABSOLUTE => 1});

my $CONFIG_FILE = "photog.ini";

=head1 NAME

Photog! - The Photography Website Generator

=head1 SYNOPSIS

B<photog> [I<-q>] [I<-v>] [I<destination>]

=head1 DESCRIPTION

Photog! turns a directory tree of source images into a photography
website with nested albums of chronologically sorted photographs. To
get started, simply C<cd> to the source directory and call C<photog>
with the destination directory as its argument. Example:

    $ cd ~/Pictures
    $ photog /var/www

Subsequent runs of the C<photog> command do nothing unless images
inside the source directory tree have changed. Photog! only
regenerates the parts of the website that should be updated.

=head1 OPTIONS

=over

=item B<-q>

Be less verbose

=item B<-v>

Be more verbose

=back

=head1 CONFIGURATION

Photog! reads configuration directives from a file named C<photog.ini>
inside the current directory. Subdirectories can contain additional
configuration files that override certain settings from the root
configuration file. Config files use L<Config::General(3pm)> syntax,
meaning they contain a number of C<variable = value> directives. The
C<=>-sign is optional, as is quoting variables. Lines starting with a
C<#> are ignored.

=over

=item B<title>

In the default template, the title appears at the top of the
page. The default value is the name of an album's source directory.

=item B<copyright>

In the default template, the copyright information appears at the
bottom of the page. The default value is empty.

=item B<template>

Path to an HTML file containing directives in
L<Template::Toolkit(3pm)> syntax. By default, Photog! uses the file
C<index.template> in this module's C<static> directory.

=item B<destination>

The destination directory. This variable has no default. It must be
specified as a command line argument or in the configuration
file.

=item B<sort>

Photos are always sorted according to EXIF date. Possible sort orders
are: C<ascending> and C<descending>. The default value is
C<descending>.

=item B<preview>

The number of images to include in an album preview. Default: 9.

=item B<slug>

The URL slug of the album that will be created from the current
directory. The default value is the directory's name.

=item B<date>

The ISO 8601 date and optionally time of this album. This is used when
sorting items chronologically. The default is the directory's
modification date.

=item B<fullscreen>

A boolean C<true> or C<false> to determine full-screen
capability. This prevents access to full-size images by clients who
haven't paid yet. Defaults to C<true>.

=item B<unlisted>

A boolean C<true> or C<false> that determines whether the current
album will be be unlisted on the parent webpage. The album page
remains accessible to people who know the URL. Defaults to C<false>.

=item B<private>

Like B<unlisted>, but Photog! will generate a random slug to use as
the album's URL and stores it in a file named C<PRIVATE.URL> inside
the album's source directory. Defaults to C<false>.

=item B<oblivious>

A boolean C<true> or C<false> that specifies whether C<photog.ini>
files are required. If C<true>, Photog! will only consider a
subdirectory an album when it contains a C<photog.ini> file, even if
the file is empty. Defaults to C<false>.

=back

=head1 SEE ALSO

L<Photography::Website(3pm)>, the Perl module that takes care of the
actual site generation.

=head1 AUTHOR

Photog! was written by Jaap Joris Vens <jj@rtts.eu>, and is used on
his personal photography website http://www.superformosa.nl/

=cut

######################################################################

die "ERROR: ImageMagick is not installed\n"
    unless `convert --version` =~ /ImageMagick/;

my $silent = 0;
my $verbose = 0;
my $source = getcwd();
my $destination;

for (@ARGV) {
    if ($_ eq '-v') {
        $verbose = 1;
    }
    elsif ($_ eq '-q') {
        $silent = 1;
    }
    elsif (not defined $destination) {
        $destination = $_;
    }
    else {
        die "Too many command-line arguments\n";
    }
}

if (not -f "$source/photog.ini" and not defined $destination) {
    die "Please specifiy a destination for your photography website. You can do this as a command-line argument ('photog ../public_html') or in the configuration file 'photog.ini'. See 'man photog' for more information.\n";
}

# Process the pictures tree
my $website = create_album($source);

# Generate the website
generate($website);

######################################################################

sub create_album {
    my $source = shift;
    my $parent = shift || 0; # optional
    my $album = configure($source, $parent) || return;
    for (list($source)) {
        my $item;
        if (-f) {
            $item = create_img($_, $album) || next;
        }
        elsif (-d) {
            $item = create_album($_, $album) || next;
        }
        push @{$album->{items}}, $item;
    }
    return $album;
}

sub create_img {
    my $source = shift;
    my $parent = shift;
    return if not is_image($source);
    my $img = {};
    my $filename = basename($source);
    $img->{type}        = 'image';
    $img->{name}        = strip_suffix($filename);
    $img->{url}         = $parent->{url} . $filename;
    $img->{href}        = $filename;
    $img->{src}         = "thumbnails/$filename";
    $img->{source}      = $source;
    $img->{destination} = catfile($parent->{destination}, $img->{url});
    $img->{thumbnail}   = catfile($parent->{destination}, $img->{src});
    $img->{watermark}   = $parent->{watermark};
    return $img;
}

sub configure {
    my $source = shift;
    my $parent = shift || 0; # optional
    my $album = get_config($source);

    # Special case for root albums
    $parent = $album if not $parent;

    # Implementation of the "oblivious" feature
    if (not $album) {
        return if $parent->{oblivious};
        $album = {};
    }

    # Implementation of the "private" feature
    if ($album->{private}) {
        $album->{slug} = random_regex('[1-9][a-hjkp-z2-9]{15}');
        $album->{unlisted} = "true";
        delete $album->{private};
        save_config($album, $source);
    }

    # FIXED PARAMETERS
    # These cannot be changed from a config file.
    $album->{type}   = 'album';
    $album->{source} = $source;
    $album->{name}   = basename($source);
    $album->{root}   = $parent->{root} || $parent->{destination} || die
        "ERROR: Destination not specified";

    # SPECIAL PARAMETERS
    # Either set in the config file or calculated dynamically
    $album->{slug}        ||= basename($source);
    $album->{url}         ||= $parent->{url} ? "$parent->{url}$album->{slug}/": "/";
    $album->{href}        ||= $album->{slug} . '/';
    $album->{src}         ||= $album->{href} . "thumbnails/all.jpg";
    $album->{destination} ||= catfile($album->{root}, substr($album->{url}, 1));
    $album->{thumbnail}   ||= catfile($album->{destination}, "thumbnails/all.jpg");
    $album->{unlisted}    ||= ($album == $parent);

    # REGULAR PARAMETERS
    # Set in the config file, propagated from parent, or a default value.
    $album->{title}      ||= $parent->{title}      || "My Photography Website";
    $album->{copyright}  ||= $parent->{copyright}  || '';
    $album->{template}   ||= $parent->{template}   || dist_file('Photog', 'template.html');
    $album->{preview}    ||= $parent->{preview}    || 9;
    $album->{watermark}  ||= $parent->{watermark}  || '';
    $album->{sort}       ||= $parent->{sort}       || 'descending';
    $album->{fullscreen} ||= $parent->{fullscreen} || 1;
    $album->{oblivious}  ||= $parent->{oblivious}  || 0;

    return $album;
}

######################################################################

sub generate {
    my $album = shift;
    my $parent = shift || 0 # optional;
    my $update_needed = 0;

    for my $item (@{$album->{items}}) {
        if ($item->{type} eq 'image') {
            update_image($item) and $update_needed = 1;
            update_thumbnail($item) and $update_needed = 1;
        }
        if ($item->{type} eq 'album') {
            generate($item, $parent) and $update_needed = 1;
        }
    }
    update_preview($album, $parent) and $update_needed = 1;

    # This is a relic from an older version of Photog, where I would
    # have to conti
    has_index($album) or $update_needed = 1;

    if ($update_needed) {
        update_index($album);
    }
}

sub update_image {
    my $img = shift;
    return if is_newer($img->{destination}, $img->{source});

    say $img->{url} unless $silent;
    make_path(dirname($img->{destination}));
    if ($img->{watermark}) {
        system('photog-watermark',
               $img->{source},
               $img->{watermark},
               $img->{destination},
           );
    }
    else {
        system('photog-scale',
               $img->{source},
               $img->{destination},
           );
    }
    return 1;
}


sub update_thumbnail {
    my $img = shift;
    return if is_newer($img->{thumbnail}, $img->{source});

    say $img->{thumbnail} unless $silent;
    make_path(dirname($img->{thumbnail}));
    system('photog-thumbnail',
           $img->{source},
           $img->{thumbnail},
       );
    return 1;
}

sub update_preview {
    my $album = shift;
    my $parent = shift || 0; # optional
    return if $album->{unlisted};
    return if -f $album->{thumbnail};

    my @images = grep { $->{type} eq 'image' } @{$album->{items}};

    if ($parent) {
        my @exclude = grep { $->{type} eq 'image' } @{$parent->{items}};
        for (@images
                 
                 
                 
        if ($parent) {
        # Create an list of all image thumbnails whose filename

        my @images;
        for (@{$parent->{items}}) {
            next unless $_->{type} eq 'image';
            say $_->{href};
            push @images, $_ unless exists $excl{$_->{href}};
        }

        # get items from array @a that are not in array @b
        my @minus = array_minus( @a, @b );

    say for @images;
    say for keys %excl;

    my $size = scalar @images;
    if ($size < $album->{preview}) {
        die "ERROR: The album '$album->{name}' is configured to show $album->{preview} preview images, but it only contains $size images.\n";
    }
    
    # Shuffle the list and pick N preview images
    my @preview = @{[shuffle @images]}[0..($album->{preview})-1];

    make_path(dirname($album->{thumbnail}));

    die "I'm dying to execute system('photog-preview', @preview, $album-{thumbnail})";

    return 1;
}

sub update_index {
    my $album = shift;
    my $index = catfile($album->{destination}, "index.html");

    # Calculate the path to the static resources, relative
    # to the current page (relative pathnames ensure that
    # the website can be viewed by a browser locally)
    my $rel = $album->{url};
    $rel =~ s:[^/]+/:\.\./:g;
    $rel =~ s:^/::;
    $album->{static} = sub { "$rel$_[0]" };

    # Render index.html
    say "$album->{url}index.html" unless $silent;
    $tt->process($album->{template}, $album, $index)
        || die $tt->error();
}


######################################################################

sub get_config {
    my $directory = shift;
    my $file = catfile($directory, $CONFIG_FILE);
    if (-f $file) {
        return ParseConfig(-ConfigFile=>$file, -AutoTrue=>1);
    }
    return 0;
}

sub save_config {
    my $config = shift;
    my $directory = shift;
    my $file = catfile($directory ,$CONFIG_FILE);
    open(my $fh, '>', $file)
        or die "ERROR: Can't open '$file' for writing\n";
    for my $key (keys %{$config}) {
        say $fh "$key = $config->{$key}";
    }
}

sub list {
    my $dir = shift;
    my @files;
    my @dirs;
    opendir(my $dh, $dir) or die
        "ERROR: Cannot read contents of directory '$dir'\n";
    while (readdir $dh) {
        next if /^\./;
        push @files, "$dir/$_" if -f "$dir/$_";
        push @dirs, "$dir/$_" if -d "$dir/$_";
    }
    sub alphabetical { lc($a) cmp lc($b) }
    @files = sort alphabetical @files;
    @dirs = sort alphabetical @dirs;
    return @dirs, @files;
}

sub is_image {
    return shift =~ /\.jpg$/;
}

sub strip_suffix {
    my $file = shift;
    $file =~ s/\.[^\.]+$//;
    return $file;
}

sub is_newer {
    my $file1 = shift;
    my $file2 = shift;
    return unless -f $file1 and -f $file2;
    my $time1 = (stat $file1)[9];
    my $time2 = (stat $file2)[9];
    return $time1 > $time2;
}

sub has_index {
    my $album = shift;
    my $index = catfile($album->{destination}, "index.html");
    return -f $index;
}
