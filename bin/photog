#!/usr/bin/perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Algorithm/Numerical/Shuffle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ALGORITHM_NUMERICAL_SHUFFLE';
  package Algorithm::Numerical::Shuffle;
  
  use 5.006;
  
  use strict;
  use warnings;
  no  warnings 'syntax';
  use Exporter ();
  
  our @ISA       = qw /Exporter/;
  our @EXPORT    = qw //;
  our @EXPORT_OK = qw /shuffle/;
  
  our $VERSION   = '2009110301';
  
  sub shuffle {
      return @_ if !@_ || ref $_ [0] eq 'ARRAY' && !@{$_ [0]};
      my $array = @_ == 1 && ref $_ [0] eq 'ARRAY' ? shift : [@_];
      for (my $i = @$array; -- $i;) {
          my $r = int rand ($i + 1);
         ($array -> [$i], $array -> [$r]) = ($array -> [$r], $array -> [$i]);
      }
      wantarray ? @$array : $array;
  }
  
  
  __END__
  
  =head1 NAME
  
  Algorithm::Numerical::Shuffle - Shuffle a list.
  
  =head1 SYNOPSIS
  
      use Algorithm::Numerical::Shuffle qw /shuffle/;
  
      @shuffled = shuffle (1, 2, 3, 4, 5, 6, 7);
  
      $in_situ = [qw /one two three four five six/];
      shuffle $in_situ;
  
  =head1 DESCRIPTION
  
  C<shuffle> performs a one pass, fair shuffle on a list. If the list is
  passed as a reference to an array, the shuffle is done in situ.
  
  The subroutine returns the list in list context, and a reference to
  the list in scalar context.
  
  =head1 COMPLEXITY
  
  The running time of the algorithm is linear in the size of the list.
  For an in situ shuffle, the memory overhead is constant; otherwise,
  linear extra memory is used.
  
  =head1 LITERATURE
  
  The algorithm used is discussed by Knuth [3]. It was first published
  by Fisher and Yates [2], and later by Durstenfeld [1].
  
  =head1 CAVEAT
  
  Salfi [4] points to a big caveat. If the outcome of a random generator
  is solely based on the value of the previous outcome, like a linear
  congruential method, then the outcome of a shuffle depends on exactly
  three things: the shuffling algorithm, the input and the seed of the
  random generator. Hence, for a given list and a given algorithm, the
  outcome of the shuffle is purely based on the seed. Many modern computers
  have 32 bit random numbers, hence a 32 bit seed. Hence, there are at
  most 2^32 possible shuffles of a list, foreach of the possible algorithms.
  But for a list of n elements, there are n! possible permutations.
  Which means that a shuffle of a list of 13 elements will not generate
  certain permutations, as 13! > 2^32.
  
  =head1 REFERENCES
  
  =over
  
  =item [1]
  
  R. Durstenfeld: I<CACM>, B<7>, 1964. pp 420.
  
  =item [2] 
  
  R. A. Fisher and F. Yates: I<Statistical Tables>. London, 1938.
  Example 12.
  
  =item [3]
  
  D. E. Knuth: I<The Art of Computer Programming>, Volume 2, Third edition.
  Section 3.4.2, Algorithm P, pp 145. Reading: Addison-Wesley, 1997.
  ISBN: 0-201-89684-2.
  
  =item [4]
  
  R. Salfi: I<COMPSTAT 1974>. Vienna: 1974, pp 28 - 35.
  
  =back
  
  =head1 SEE ALSO
  
  C<< List::Util >> also has a C<< shuffle >> function which uses a similar
  algorithm. But since it's written in C, it's much faster. For all practical
  purposes, C<< List::Util >> supersedes this module. Unless you really need
  in situ sorting.
  
  =head1 DEVELOPMENT
   
  The current sources of this module are found on github,
  L<< git://github.com/Abigail/algorithm--numerical--shuffle.git >>.
  
  =head1 AUTHOR
  
  Abigail L<< mailto:cpan@abigail.be >>.
  
  =head1 COPYRIGHT and LICENSE
  
  Copyright (C) 1998 - 2000, 2009 by Abigail.
  
  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  and/or sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:
       
  The above copyright notice and this permission notice shall be included
  in all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
  THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
  OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
  
  =cut
ALGORITHM_NUMERICAL_SHUFFLE

$fatpacked{"File/ShareDir/PAR.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_SHAREDIR_PAR';
  package File::ShareDir::PAR;
  
  =pod
  
  =head1 NAME
  
  File::ShareDir::PAR - File::ShareDir with PAR support
  
  =head1 SYNOPSIS
  
    use File::SharedDir::PAR ':ALL';
    # exact same interface as the normal File::ShareDir:
    
    # Where are distribution-level shared data files kept
    $dir = dist_dir('File-ShareDir');
    
    # Where are module-level shared data files kept
    $dir = module_dir('File::ShareDir');
    
    # Find a specific file in our dist/module shared dir
    $file = dist_file(  'File-ShareDir',  'file/name.txt');
    $file = module_file('File::ShareDir', 'file/name.txt');
    
    # Like module_file, but search up the inheritance tree
    $file = class_file( 'Foo::Bar', 'file/name.txt' );
  
  You may choose to install the C<File::ShareDir::PAR>
  functions into C<File::ShareDir> so that they become available
  globally. In that case, you must do the following before
  anybody can import functions from C<File::ShareDir>:
  
    use File::ShareDir::PAR 'global';
  
  =head1 WARNING
  
  This module contains I<highly experimental> code. If you want
  to load modules from C<.par> files using PAR
  and then access their shared directory using C<File::ShareDir>,
  you probably have no choice but to use it. But beware,
  here be dragons.
  
  =head1 DESCRIPTION
  
  C<File::ShareDir::PAR> provides the same functionality
  as L<File::ShareDir> but tries hard to be compatible with
  L<PAR> packaged applications.
  
  The problem is, that the concept of having a distribution or
  module specific I<share> directory becomes a little hazy
  when you're loading everything from a single file.
  L<PAR> uses an C<@INC> hook to intercept any attempt to load
  a module. L<File::ShareDir> uses the directory structure that
  is typically found in the directories that are listed in C<@INC>
  for storing the shared data. In a C<PAR> enviroment, this is
  not necessarily possible.
  
  When you call one of the functions that this module provides,
  it will take care to search in any of the currently loaded
  C<.par> files before scanning C<@INC>. This is the same
  order of preference you get for loading modules when PAR is
  in effect. If the path or file you are asking for is found
  in one of the loaded C<.par> files, that containing
  C<.par> file is extracted and the path returned will
  point to the extracted copy on disk.
  
  Depending on how you're using PAR, the files that are extracted
  this way are either cleaned up after program termination
  or cached for further executions. Either way, you're safe if
  you use the shared data as read-only data. If you write to it,
  your changes may be lost after the program ends.
  
  For any further usage information, including the list of exportable
  functions, please refer to the documentation of L<File::ShareDir>.
  
  =cut
  
  use 5.005;
  use strict;
  use base 'Exporter';
  use Carp             'croak';
  use File::ShareDir   ();
  use File::Spec       ();
  use Class::Inspector ();
  use Config           ();
  use File::Path       ();
  
  use vars qw{$VERSION @EXPORT_OK %EXPORT_TAGS %CLEANUP_DIRS};
  BEGIN {
    $VERSION     = '0.06';
    @EXPORT_OK   = qw{dist_dir dist_file module_dir module_file class_file};
    %EXPORT_TAGS = (
      ALL => [ @EXPORT_OK ],
    );
  }
  
  use constant IS_MACOS => !!($^O eq 'MacOS');
  
  # cleanup temporary extraction dirs.
  # should be handled by PAR, but since we're
  # abusing it to extract full .par's to inc/,
  # we'd better take care!
  END {
    foreach my $directory (keys %CLEANUP_DIRS) {
      File::Path::rmtree($directory) if -d $directory;
    }
  }
  
  # This isn't nice: Breaking PAR encapsulation.
  # finds the specified file in the loaded .par's
  # and returns the zip member, zip file, and zip handle
  # on success
  {
    my $ver          = $Config::Config{version};
    my $arch         = $Config::Config{archname};
    sub _par_find_zip_member {
      my $files = shift;
      $files = [$files] if not ref $files;
  
      require PAR;
  
      s/\/+$// for @$files;
  
      my @files =
        map {s{\\}{/}g; $_}
        map {
          my $file = $_;
          ( $file, "lib/$file", "arch/$file", "$arch/$file", "$ver/$file", "$ver/$arch/$file" )
        }
        @$files;
  
      my $files_regexp = '^(?:' . join(')|(?:', map {quotemeta($_)} @files) . ')/?';
      foreach my $zipkey (keys %PAR::LibCache) {
        my $zip = $PAR::LibCache{$zipkey};
        my $member = PAR::_first_member_matching($zip, $files_regexp) or next;
        return($member, $zipkey, $zip);
      }
  
      return;
    }
  }
  
  sub _par_in_use {
    return() unless exists $INC{"PAR.pm"};
    return() unless @PAR::LibCache;
    return 1;
  }
  
  sub _search_and_unpar {
    my $zippaths = shift;
    $zippaths = [$zippaths] if not ref $zippaths;
  
    my ($member, $zipkey, $zip) = _par_find_zip_member($zippaths);
    if ($member) {
      if (exists $PAR::ArchivesExtracted{$zip->fileName()} or $PAR::ArchivesExtracted{$zipkey}) {
        my $inc = $PAR::ArchivesExtracted{$zip->fileName()};
        return $inc;
      }
      else {
        # watch out: breaking PAR encapsulation
        my $inc_existed = -d "$PAR::SetupTemp::PARTemp/inc" ? 1 : 0;
        my $inc = PAR::_extract_inc($zip, 'force');
        $PAR::ArchivesExtracted{$zip->fileName()} = $inc;
        if (defined $inc and not $inc_existed) {
          $CLEANUP_DIRS{$inc} = 1;
          return $inc;
        }
        return();
      }
    }
    return();
  }
  
  
  #####################################################################
  # Interface Functions
  
  my $orig_dist_dir = \&File::ShareDir::dist_dir; # save original
  sub dist_dir {
    my @args = @_;
    if (_par_in_use()) {
      my $dist = File::ShareDir::_DIST(shift);
  
      # Create the subpath
      my $zip_paths = [
        join (
          '/',
          'auto', split( /-/, $dist )
        ),
        join (
          '/',
          'auto', 'share', 'dist', split( /-/, $dist )
        )
      ];
  
      _search_and_unpar($zip_paths);
    }
  
    # hide from croak  
    @_ = @args;
    goto &$orig_dist_dir;
  }
  
  
  my $orig_module_dir = \&File::ShareDir::module_dir; # save original
  sub module_dir {
    my @args = @_;
    my $module = File::ShareDir::_MODULE(shift);
  
    my $short  = Class::Inspector->filename($module);
    if (_par_in_use()) {
      my $inc = _search_and_unpar($short);
      if (defined $inc) {
        # Holy shit, I'm so evil. Somebody will find out I did this.
        $INC{$short} = Class::Inspector->resolved_filename($module);
      }
    }
  
    # hide from croak  
    @_ = @args;
    goto &$orig_module_dir;
  }
  
  
  my $orig_dist_file = \&File::ShareDir::dist_file; # save original
  sub dist_file {
    my @args = @_;
    my $dist = File::ShareDir::_DIST(shift);
    my $file = File::ShareDir::_FILE(shift);
  
    # Create the subpath
    my $zippath = join (
      '/',
      'auto', split( /-/, $dist ), File::Spec->splitdir($file)
    );
  
    _search_and_unpar($zippath) if _par_in_use();
  
    # hide from croak  
    @_ = @args;
    goto &$orig_dist_file;
  }
  
  
  my $orig_module_file = \&File::ShareDir::module_file; # save original
  sub module_file {
    my @args = @_;
    my $module = File::ShareDir::_MODULE($_[0]);
    my $dir    = module_dir($module);
    @_ = @args;
    goto &$orig_module_file;
  }
  
  
  my $orig_class_file = \&File::ShareDir::class_file; # save original
  sub class_file {
    my @args = @_;
    my $module = File::ShareDir::_MODULE(shift);
  
    # This had to be copied from File::ShareDir.
    ### BEGIN VERBATIM COPY ###
          # Get the super path ( not including UNIVERSAL )
          # Rather than using Class::ISA, we'll use an inlined version
          # that implements the same basic algorithm.
          my @path  = ();
          my @queue = ( $module );
          my %seen  = ( $module => 1 );
          while ( my $cl = shift @queue ) {
                  push @path, $cl;
                  no strict 'refs';
                  unshift @queue, grep { ! $seen{$_}++ }
                          map { s/^::/main::/; s/\'/::/g; $_ }
                          ( @{"${cl}::ISA"} );
          }
    ### END VERBATIM COPY ###
  
    foreach my $class ( @path ) {
      eval { module_dir($class); };
    }
  
    # hide from croak
    @_ = @args;
    goto &$orig_class_file;
  }
  
  sub import {
    my $class = shift;
    my @opt = grep { $_ ne 'global' } @_;
    if (@opt < @_) { # included 'global' option
      no warnings 'redefine';
      *File::ShareDir::class_file  = \&class_file;
      *File::ShareDir::module_file = \&module_file;
      *File::ShareDir::dist_file   = \&dist_file;
      *File::ShareDir::module_dir  = \&module_dir;
      *File::ShareDir::dist_dir    = \&dist_dir;
    }
    $class->export_to_level(1, $class, @opt);
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  Bugs should always be submitted via the CPAN bug tracker
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=File-ShareDir-PAR>
  
  For other issues, contact the PAR mailing list: E<lt>par@perl.orgE<gt>
  
  =head1 AUTHOR
  
  Steffen Mueller E<lt>smueller@cpan.orgE<gt>
  
  The code was adapted from Adam Kennedy's work on C<File::ShareDir>
  
  =head1 SEE ALSO
  
  L<File::ShareDir>, L<File::HomeDir>, L<Module::Install>, L<Module::Install::Share>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (c) 2008-2010 Steffen Mueller
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The portions of code that were copied from C<File::ShareDir> are:
  
  Copyright (c) 2005, 2006 Adam Kennedy.
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_SHAREDIR_PAR

$fatpacked{"Image/Size.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IMAGE_SIZE';
  ###############################################################################
  #
  # This file copyright (c) 2015 by Randy J. Ray, all rights reserved
  #
  # Copying and distribution are permitted under the terms of the Artistic
  # License 2.0 (http://www.opensource.org/licenses/artistic-license-2.0.php) or
  # the GNU LGPL (http://www.opensource.org/licenses/lgpl-2.1.php).
  #
  ###############################################################################
  #
  # Once upon a time, this code was lifted almost verbatim from wwwis by Alex
  # Knowles, alex@ed.ac.uk. Since then, even I barely recognize it. It has
  # contributions, fixes, additions and enhancements from all over the world.
  #
  # See the file ChangeLog for change history.
  #
  ###############################################################################
  
  package Image::Size;
  
  require 5.006001;
  
  # These are the Perl::Critic policies that are being turned off globally:
  ## no critic(RequireBriefOpen)
  ## no critic(ProhibitAutomaticExportation)
  
  use strict;
  use warnings;
  use bytes;
  use vars qw(
      @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION $NO_CACHE %CACHE
      $GIF_BEHAVIOR @TYPE_MAP %PCD_MAP $PCD_SCALE $READ_IN $LAST_POS
  );
  
  use Exporter 'import';
  
  BEGIN
  {
      @EXPORT      = qw(imgsize);
      @EXPORT_OK   = qw(imgsize html_imgsize attr_imgsize
                        %CACHE $NO_CACHE $PCD_SCALE $GIF_BEHAVIOR);
      %EXPORT_TAGS = ('all' => [ @EXPORT_OK ]);
  
      $VERSION = '3.300';
      $VERSION = eval $VERSION; ## no critic(ProhibitStringyEval)
  
      # Default behavior for GIFs is to return the "screen" size
      $GIF_BEHAVIOR = 0;
  }
  
  # This allows people to specifically request that the cache not be used
  $NO_CACHE = 0;
  
  # Package lexicals - invisible to outside world, used only in imgsize
  #
  # Mapping of patterns to the sizing routines
  @TYPE_MAP = (
      qr{^GIF8[79]a}               => \&gifsize,
      qr{^\xFF\xD8}                => \&jpegsize,
      qr{^\x89PNG\x0d\x0a\x1a\x0a} => \&pngsize,
      qr{^P[1-7]}                  => \&ppmsize, # also XVpics
      qr{#define\s+\S+\s+\d+}      => \&xbmsize,
      qr{/[*] XPM [*]/}            => \&xpmsize,
      qr{^MM\x00\x2a}              => \&tiffsize,
      qr{^II\x2a\x00}              => \&tiffsize,
      qr{^BM}                      => \&bmpsize,
      qr{^8BPS}                    => \&psdsize,
      qr{^PCD_OPA}                 => \&pcdsize,
      qr{^FWS}                     => \&swfsize,
      qr{^CWS}                     => \&swfmxsize,
      qr{^\x8aMNG\x0d\x0a\x1a\x0a} => \&mngsize,
      qr{^\x01\x00\x00\x00}        => \&emfsize,
      qr{^RIFF(?s:....)WEBP}       => \&webpsize,
      qr{^\x00\x00\x01\x00}        => \&icosize,
      qr{^\x00\x00\x02\x00}        => \&cursize,
  );
  # Kodak photo-CDs are weird. Don't ask me why, you really don't want details.
  %PCD_MAP = ( 'base/16' => [ 192,  128  ],
               'base/4'  => [ 384,  256  ],
               'base'    => [ 768,  512  ],
               'base4'   => [ 1536, 1024 ],
               'base16'  => [ 3072, 2048 ],
               'base64'  => [ 6144, 4096 ], );
  # Default scale for PCD images
  $PCD_SCALE = 'base';
  
  # These are lexically-scoped anonymous subroutines for reading the three
  # types of input streams. When the input to imgsize() is typed, then the
  # lexical "read_in" is assigned one of these, thus allowing the individual
  # routines to operate on these streams abstractly.
  
  my $read_io = sub {
      my $handle = shift;
      my ($length, $offset) = @_;
  
      if (defined($offset) && ($offset != $LAST_POS))
      {
          $LAST_POS = $offset;
          return q{} if (! seek $handle, $offset, 0);
      }
  
      my ($buffer, $rtn) = (q{}, 0);
      $rtn = read $handle, $buffer, $length;
      if (! $rtn)
      {
          $buffer = q{};
      }
      $LAST_POS = tell $handle;
  
      return $buffer;
  };
  
  my $read_buf = sub {
      my $buf = shift;
      my ($length, $offset) = @_;
  
      if (defined($offset) && ($offset != $LAST_POS))
      {
          $LAST_POS = $offset;
          return q{} if ($LAST_POS > length ${$buf});
      }
  
      my $content = substr ${$buf}, $LAST_POS, $length;
      $LAST_POS += length $content;
  
      return $content;
  };
  
  sub imgsize ## no critic(ProhibitExcessComplexity)
  {
      my $stream = shift;
  
      my ($handle, $header);
      my ($x, $y, $id, $mtime, @list);
      # These only used if $stream is an existing open FH
      my ($save_pos, $need_restore) = (0, 0);
      # This is for when $stream is a locally-opened file
      my $need_close = 0;
      # This will contain the file name, if we got one
      my $file_name = undef;
  
      $header = q{};
  
      if (ref($stream) eq 'SCALAR')
      {
          $handle = $stream;
          $READ_IN = $read_buf;
          $header = substr ${$handle} || q{}, 0, 256;
      }
      elsif (ref $stream)
      {
          # I no longer require $stream to be in the IO::* space. So I'm assuming
          # you don't hose yourself by passing a ref that can't do fileops. If
          # you do, you fix it.
          $handle = $stream;
          $READ_IN = $read_io;
          $save_pos = tell $handle;
          $need_restore = 1;
  
          # First alteration (didn't wait long, did I?) to the existing handle:
          #
          # assist dain-bramaged operating systems -- SWD
          # SWD: I'm a bit uncomfortable with changing the mode on a file
          # that something else "owns" ... the change is global, and there
          # is no way to reverse it.
          # But image files ought to be handled as binary anyway.
          binmode $handle;
          seek $handle, 0, 0;
          read $handle, $header, 256;
          seek $handle, 0, 0;
      }
      else
      {
          if (! $NO_CACHE)
          {
              require Cwd;
              require File::Spec;
  
              if (! File::Spec->file_name_is_absolute($stream))
              {
                  $stream = File::Spec->catfile(Cwd::cwd(), $stream);
              }
              $mtime = (stat $stream)[9];
              if (-e "$stream" and exists $CACHE{$stream})
              {
                  @list = split /,/, $CACHE{$stream}, 4;
  
                  # Don't return the cache if the file is newer.
                  if ($mtime <= $list[0])
                  {
                      return @list[1 .. 3];
                  }
                  # In fact, clear it
                  delete $CACHE{$stream};
              }
          }
  
          # first try to open the stream
          require Symbol;
          $handle = Symbol::gensym();
          if (! open $handle, '<', $stream)
          {
              return (undef, undef, "Can't open image file $stream: $!");
          }
  
          $need_close = 1;
          # assist dain-bramaged operating systems -- SWD
          binmode $handle;
          read $handle, $header, 256;
          seek $handle, 0, 0;
          $READ_IN = $read_io;
          $file_name = $stream;
      }
      $LAST_POS = 0;
  
      # Right now, $x, $y and $id are undef. If the while-loop below doesn't
      # match the header to a file-type and call a subroutine, then the later
      # block that tried Image::Magick will default to setting the id/error to
      # "unknown file type".
      my $tm_idx = 0;
      while ($tm_idx < @TYPE_MAP)
      {
          if ($header =~ $TYPE_MAP[$tm_idx])
          {
              ($x, $y, $id) = $TYPE_MAP[$tm_idx + 1]->($handle);
              last;
          }
          $tm_idx += 2;
      }
  
      # Added as an afterthought: I'm probably not the only one who uses the
      # same shaded-sphere image for several items on a bulleted list:
      if (! ($NO_CACHE or (ref $stream) or (! defined $x)))
      {
          $CACHE{$stream} = join q{,}, $mtime, $x, $y, $id;
      }
  
      # If we were passed an existing file handle, we need to restore the
      # old filepos:
      if ($need_restore)
      {
          seek $handle, $save_pos, 0;
      }
      # ...and if we opened the file ourselves, we need to close it
      if ($need_close)
      {
          close $handle; ## no critic(RequireCheckedClose)
      }
  
      if (! defined $id)
      {
          if ($file_name)
          {
              # Image::Magick operates on file names.
              ($x, $y, $id) = imagemagick_size($file_name);
          }
          else
          {
              $id = 'Data stream is not a known image file format';
          }
      }
  
      # results:
      return (wantarray) ? ($x, $y, $id) : ();
  }
  
  sub imagemagick_size
  {
      my $file_name = shift;
  
      my $module_name;
      # First see if we have already loaded Graphics::Magick or Image::Magick
      # If so, just use whichever one is already loaded.
      if (exists $INC{'Graphics/Magick.pm'})
      {
          $module_name = 'Graphics::Magick';
      }
      elsif (exists $INC{'Image/Magick.pm'})
      {
          $module_name = 'Image::Magick';
      }
      # If neither are already loaded, try loading either one.
      elsif (_load_magick_module('Graphics::Magick'))
      {
         $module_name = 'Graphics::Magick';
      }
      elsif (_load_magick_module('Image::Magick'))
      {
         $module_name = 'Image::Magick';
      }
  
      if ($module_name)
      {
          my $img = $module_name->new();
          my $x = $img->Read($file_name);
          # Image::Magick error handling is a bit weird, see
          # <http://www.simplesystems.org/ImageMagick/www/perl.html#erro>
          if("$x") {
              return (undef, undef, "$x");
          } else {
              return ($img->Get('width', 'height', 'format'));
          }
  
      }
      else {
          return (undef, undef, 'Data stream is not a known image file format');
      }
  }
  
  # load Graphics::Magick or Image::Magick if one is not already loaded.
  sub _load_magick_module {
      my $module_name = shift;
      my $retval = eval {
          local $SIG{__DIE__} = q{};
          require $module_name;
          1;
      };
      return $retval ? 1 : 0;
  }
  
  
  sub html_imgsize
  {
      my @args = @_;
      @args = imgsize(@args);
  
      # Use lowercase and quotes so that it works with xhtml.
      return ((defined $args[0]) ?
              sprintf('width="%d" height="%d"', @args[0,1]) :
              undef);
  }
  
  sub attr_imgsize
  {
      my @args = @_;
      @args = imgsize(@args);
  
      return ((defined $args[0]) ?
              (('-width', '-height', @args)[0, 2, 1, 3]) :
              undef);
  }
  
  # This used only in gifsize:
  sub img_eof
  {
      my $stream = shift;
  
      if (ref($stream) eq 'SCALAR')
      {
          return ($LAST_POS >= length ${$stream});
      }
  
      return eof $stream;
  }
  
  # Simple converter-routine used by SWF and CWS code
  sub _bin2int
  {
      my $val = shift;
      # "no critic" because I want it clear which args are being used by
      # substr() versus unpack().
      ## no critic (ProhibitParensWithBuiltins)
      return unpack 'N', pack 'B32', substr(('0' x 32) . $val, -32);
  }
  
  ###########################################################################
  # Subroutine gets the size of the specified GIF
  ###########################################################################
  sub gifsize ## no critic(ProhibitExcessComplexity)
  {
      my $stream = shift;
  
      my ($cmapsize, $buf, $sh, $sw, $x, $y, $type);
  
      my $gif_blockskip = sub {
          my ($skip, $blocktype) = @_;
          my ($lbuf);
  
          $READ_IN->($stream, $skip);        # Skip header (if any)
          while (1)
          {
              if (img_eof($stream))
              {
                  return (undef, undef,
                          "Invalid/Corrupted GIF (at EOF in GIF $blocktype)");
              }
              $lbuf = $READ_IN->($stream, 1);  # Block size
              last if ord($lbuf) == 0;         # Block terminator
              $READ_IN->($stream, ord $lbuf);  # Skip data
          }
      };
  
      if ($GIF_BEHAVIOR > 2)
      {
          return (undef, undef,
                  "\$Image::Size::GIF_BEHAVIOR out of range: $GIF_BEHAVIOR");
      }
  
      # Skip over the identifying string, since we already know this is a GIF
      $type = $READ_IN->($stream, 6);
      if (length($buf = $READ_IN->($stream, 7)) != 7 )
      {
          return (undef, undef, 'Invalid/Corrupted GIF (bad header)');
      }
      ($sw, $sh, $x) = unpack 'vv C', $buf;
      if ($GIF_BEHAVIOR == 0)
      {
          return ($sw, $sh, 'GIF');
      }
  
      if ($x & 0x80)
      {
          $cmapsize = 3 * (2**(($x & 0x07) + 1));
          if (! $READ_IN->($stream, $cmapsize))
          {
              return (undef, undef,
                      'Invalid/Corrupted GIF (global color map too small?)');
          }
      }
  
      # Before we start this loop, set $sw and $sh to 0s and use them to track
      # the largest sub-image in the overall GIF.
      $sw = $sh = 0;
  
    FINDIMAGE:
      while (1)
      {
          if (img_eof($stream))
          {
              # At this point, if we haven't returned then the user wants the
              # largest of the sub-images. So, if $sh and $sw are still 0s, then
              # we didn't see even one Image Descriptor block. Otherwise, return
              # those two values.
              if ($sw and $sh)
              {
                  return ($sw, $sh, 'GIF');
              }
              else
              {
                  return (undef, undef,
                          'Invalid/Corrupted GIF (no Image Descriptors)');
              }
          }
          $buf = $READ_IN->($stream, 1);
          ($x) = unpack 'C', $buf;
          if ($x == 0x2c)
          {
              # Image Descriptor (GIF87a, GIF89a 20.c.i)
              if (length($buf = $READ_IN->($stream, 8)) != 8)
              {
                  return (undef, undef,
                          'Invalid/Corrupted GIF (missing image header?)');
              }
              ($x, $y) = unpack 'x4 vv', $buf;
              return ($x, $y, 'GIF') if ($GIF_BEHAVIOR == 1);
              if ($x > $sw and $y > $sh)
              {
                  $sw = $x;
                  $sh = $y;
              }
          }
          if ($x == 0x21)
          {
              # Extension Introducer (GIF89a 23.c.i, could also be in GIF87a)
              $buf = $READ_IN->($stream, 1);
              ($x) = unpack 'C', $buf;
              if ($x == 0xF9)
              {
                  # Graphic Control Extension (GIF89a 23.c.ii)
                  $READ_IN->($stream, 6);    # Skip it
                  next FINDIMAGE;       # Look again for Image Descriptor
              }
              elsif ($x == 0xFE)
              {
                  # Comment Extension (GIF89a 24.c.ii)
                  $gif_blockskip->(0, 'Comment');
                  next FINDIMAGE;       # Look again for Image Descriptor
              }
              elsif ($x == 0x01)
              {
                  # Plain Text Label (GIF89a 25.c.ii)
                  $gif_blockskip->(13, 'text data');
                  next FINDIMAGE;       # Look again for Image Descriptor
              }
              elsif ($x == 0xFF)
              {
                  # Application Extension Label (GIF89a 26.c.ii)
                  $gif_blockskip->(12, 'application data');
                  next FINDIMAGE;       # Look again for Image Descriptor
              }
              else
              {
                  return (undef, undef,
                          sprintf 'Invalid/Corrupted GIF (Unknown ' .
                                  'extension %#x)', $x);
              }
          }
          else
          {
              return (undef, undef,
                      sprintf 'Invalid/Corrupted GIF (Unknown code %#x)', $x);
          }
      }
  
      return (undef, undef, 'gifsize fell through to the end, error');
  }
  
  sub xbmsize
  {
      my $stream = shift;
  
      my $input;
      my ($x, $y, $id) = (undef, undef, 'Could not determine XBM size');
  
      $input = $READ_IN->($stream, 1024);
      if ($input =~ /^\#define\s*\S*\s*(\d+)\s*\n\#define\s*\S*\s*(\d+)/ix)
      {
          ($x, $y) = ($1, $2);
          $id = 'XBM';
      }
  
      return ($x, $y, $id);
  }
  
  # Added by Randy J. Ray, 30 Jul 1996
  # Size an XPM file by looking for the "X Y N W" line, where X and Y are
  # dimensions, N is the total number of colors defined, and W is the width of
  # a color in the ASCII representation, in characters. We only care about X & Y.
  sub xpmsize
  {
      my $stream = shift;
  
      my $line;
      my ($x, $y, $id) = (undef, undef, 'Could not determine XPM size');
  
      while ($line = $READ_IN->($stream, 1024))
      {
          if ($line =~ /"\s*(\d+)\s+(\d+)(\s+\d+\s+\d+){1,2}\s*"/)
          {
              ($x, $y) = ($1, $2);
              $id = 'XPM';
              last;
          }
      }
  
      return ($x, $y, $id);
  }
  
  # pngsize : gets the width & height (in pixels) of a png file
  # cor this program is on the cutting edge of technology! (pity it's blunt!)
  #
  # Re-written and tested by tmetro@vl.com
  sub pngsize
  {
      my $stream = shift;
  
      my ($x, $y, $id) = (undef, undef, 'Could not determine PNG size');
      my ($offset, $length);
  
      # Offset to first Chunk Type code = 8-byte ident + 4-byte chunk length + 1
      $offset = 12; $length = 4;
      if ($READ_IN->($stream, $length, $offset) eq 'IHDR')
      {
          # IHDR = Image Header
          $length = 8;
          ($x, $y) = unpack 'NN', $READ_IN->($stream, $length);
          $id = 'PNG';
      }
  
      return ($x, $y, $id);
  }
  
  # mngsize: gets the width and height (in pixels) of an MNG file.
  # See <URL:http://www.libpng.org/pub/mng/spec/> for the specification.
  #
  # Basically a copy of pngsize.
  sub mngsize
  {
      my $stream = shift;
  
      my ($x, $y, $id) = (undef, undef, 'Could not determine MNG size');
      my ($offset, $length);
  
      # Offset to first Chunk Type code = 8-byte ident + 4-byte chunk length + 1
      $offset = 12; $length = 4;
      if ($READ_IN->($stream, $length, $offset) eq 'MHDR')
      {
          # MHDR = Image Header
          $length = 8;
          ($x, $y) = unpack 'NN', $READ_IN->($stream, $length);
          $id = 'MNG';
      }
  
      return ($x, $y, $id);
  }
  
  # jpegsize: gets the width and height (in pixels) of a jpeg file
  # Andrew Tong, werdna@ugcs.caltech.edu           February 14, 1995
  # modified slightly by alex@ed.ac.uk
  # and further still by rjray@blackperl.com
  # optimization and general re-write from tmetro@vl.com
  sub jpegsize
  {
      my $stream = shift;
  
      my $MARKER     = chr 0xff; # Section marker
  
      my $SIZE_FIRST = 0xC0;   # Range of segment identifier codes
      my $SIZE_LAST  = 0xC3;   #  that hold size info.
  
      my ($x, $y, $id) = (undef, undef, 'Could not determine JPEG size');
  
      my ($marker, $code, $length);
      my $segheader;
  
      # Dummy read to skip header ID
      $READ_IN->($stream, 2);
      while (1)
      {
          $segheader = $READ_IN->($stream, 2);
  
          # Extract the segment header.
          ($marker, $code) = unpack 'a a', $segheader;
  
          while ( $code eq $MARKER && ($marker = $code) ) {
              $segheader = $READ_IN->($stream, 1);
              ($code) = unpack 'a', $segheader;
          }
          $segheader = $READ_IN->($stream, 2);
          $length = unpack 'n', $segheader;
  
          # Verify that it's a valid segment.
          if ($marker ne $MARKER)
          {
              # Was it there?
              $id = 'JPEG marker not found';
              last;
          }
          elsif ((ord($code) >= $SIZE_FIRST) && (ord($code) <= $SIZE_LAST))
          {
              # Segments that contain size info
              $length = 5;
              my $buf = $READ_IN->($stream, $length);
              # unpack dies on truncated data
              last if (length($buf) < $length);
              ($y, $x) = unpack 'xnn', $buf;
              $id = 'JPG';
              last;
          }
          else
          {
              # Dummy read to skip over data
              $READ_IN->($stream, ($length - 2));
          }
      }
  
      return ($x, $y, $id);
  }
  
  # ppmsize: gets data on the PPM/PGM/PBM family.
  #
  # Contributed by Carsten Dominik <dominik@strw.LeidenUniv.nl>
  sub ppmsize
  {
      my $stream = shift;
  
      my ($x, $y, $id) =
          (undef, undef, 'Unable to determine size of PPM/PGM/PBM data');
      my $n;
      my @table = qw(nil PBM PGM PPM PBM PGM PPM);
  
      my $header = $READ_IN->($stream, 1024);
  
      # PPM file of some sort
      $header =~ s/^\#.*//mg;
      if ($header =~ /^(?:P([1-7]))\s+(\d+)\s+(\d+)/)
      {
          ($n, $x, $y) = ($1, $2, $3);
  
          if ($n == 7)
          {
              # John Bradley's XV thumbnail pics (from inwap@jomis.Tymnet.COM)
              $id = 'XV';
              ($x, $y) = ($header =~ /IMGINFO:(\d+)x(\d+)/s);
          }
          else
          {
              $id = $table[$n];
          }
      }
  
      return ($x, $y, $id);
  }
  
  # tiffsize: size a TIFF image
  #
  # Contributed by Cloyce Spradling <cloyce@headgear.org>
  sub tiffsize
  {
      my $stream = shift;
  
      my ($x, $y, $id) = (undef, undef, 'Unable to determine size of TIFF data');
  
      my $endian = 'n';           # Default to big-endian; I like it better
      my $header = $READ_IN->($stream, 4);
      if ($header =~ /II\x2a\x00/o)
      {
          # little-endian
          $endian = 'v';
      }
  
      # Set up an association between data types and their corresponding
      # pack/unpack specification.  Don't take any special pains to deal with
      # signed numbers; treat them as unsigned because none of the image
      # dimensions should ever be negative. (I hope.)
      my @packspec = ( undef,      # nothing (shouldn't happen)
                       'C',        # BYTE (8-bit unsigned integer)
                       undef,      # ASCII
                       $endian,    # SHORT (16-bit unsigned integer)
                       uc $endian, # LONG (32-bit unsigned integer)
                       undef,      # RATIONAL
                       'c',        # SBYTE (8-bit signed integer)
                       undef,      # UNDEFINED
                       $endian,    # SSHORT (16-bit unsigned integer)
                       uc $endian, # SLONG (32-bit unsigned integer)
                       );
  
      my $offset = $READ_IN->($stream, 4, 4); # Get offset to IFD
      $offset = unpack uc $endian, $offset; # Fix it so we can use it
  
      my $ifd = $READ_IN->($stream, 2, $offset); # Get num. of directory entries
      my $num_dirent = unpack $endian, $ifd; # Make it useful
      $offset += 2;
      $num_dirent = $offset + ($num_dirent * 12); # Calc. maximum offset of IFD
  
      # Do all the work
      $ifd = q{};
      my $tag = 0;
      my $type = 0;
      while ((! defined $x) || (! defined$y)) {
          $ifd = $READ_IN->($stream, 12, $offset);   # Get first directory entry
          last if (($ifd eq q{}) || ($offset > $num_dirent));
          $offset += 12;
          $tag = unpack $endian, $ifd;               # ...and decode its tag
          $type = unpack $endian, substr $ifd, 2, 2; # ...and the data type
          # Check the type for sanity.
          next if (($type > @packspec+0) || (! defined $packspec[$type]));
          if ($tag == 0x0100)    # ImageWidth (x)
          {
              # Decode the value
              $x = unpack $packspec[$type], substr $ifd, 8, 4;
          }
          elsif ($tag == 0x0101) # ImageLength (y)
          {
              # Decode the value
              $y = unpack $packspec[$type], substr $ifd, 8, 4;
          }
      }
  
      # Decide if we were successful or not
      if (defined $x and defined $y)
      {
          $id = 'TIF';
      }
      else
      {
          $id = q{};
          if (! defined $x)
          {
              $id = 'ImageWidth ';
          }
          if (! defined $y)
          {
              if ($id ne q{})
              {
                  $id .= 'and ';
              }
              $id .= 'ImageLength ';
          }
          $id .= 'tag(s) could not be found';
      }
  
      return ($x, $y, $id);
  }
  
  # bmpsize: size a Windows-ish BitMaP image
  #
  # Adapted from code contributed by Aldo Calpini <a.calpini@romagiubileo.it>
  sub bmpsize
  {
      my $stream = shift;
  
      my ($x, $y, $id) = (undef, undef, 'Unable to determine size of BMP data');
      my $buffer;
  
      $buffer = $READ_IN->($stream, 26);
      my $header_size = unpack 'x14V', $buffer;
      if ($header_size == 12)
      {
          ($x, $y) = unpack 'x18vv', $buffer;     # old OS/2 header
      }
      else
      {
          ($x, $y) = unpack 'x18VV', $buffer;     # modern Windows header
      }
      if (defined $x and defined $y)
      {
          $id = 'BMP';
      }
  
      return ($x, $y, $id);
  }
  
  # psdsize: determine the size of a PhotoShop save-file (*.PSD)
  sub psdsize
  {
      my $stream = shift;
  
      my ($x, $y, $id) = (undef, undef, 'Unable to determine size of PSD data');
      my $buffer;
  
      $buffer = $READ_IN->($stream, 26);
      ($y, $x) = unpack 'x14NN', $buffer;
      if (defined $x and defined $y)
      {
          $id = 'PSD';
      }
  
      return ($x, $y, $id);
  }
  
  # swfsize: determine size of ShockWave/Flash files. Adapted from code sent by
  # Dmitry Dorofeev <dima@yasp.com>
  sub swfsize
  {
      my $image  = shift;
      my $header = $READ_IN->($image, 33);
  
      my $ver = _bin2int(unpack 'B8', substr $header, 3, 1);
      my $bs = unpack 'B133', substr $header, 8, 17;
      my $bits = _bin2int(substr $bs, 0, 5);
      my $x = int _bin2int(substr $bs, 5+$bits, $bits)/20;
      my $y = int _bin2int(substr $bs, 5+$bits*3, $bits)/20;
  
      return ($x, $y, 'SWF');
  }
  
  # Suggested by Matt Mueller <mueller@wetafx.co.nz>, and based on a piece of
  # sample Perl code by a currently-unknown author. Credit will be placed here
  # once the name is determined.
  sub pcdsize
  {
      my $stream = shift;
  
      my ($x, $y, $id) = (undef, undef, 'Unable to determine size of PCD data');
      my $buffer = $READ_IN->($stream, 0xf00);
  
      # Second-tier sanity check
      if (substr($buffer, 0x800, 3) ne 'PCD')
      {
          return ($x, $y, $id);
      }
  
      my $orient = ord(substr $buffer, 0x0e02, 1) & 1; # Clear down to one bit
      ($x, $y) = @{$Image::Size::PCD_MAP{lc $Image::Size::PCD_SCALE}}
          [($orient ? (0, 1) : (1, 0))];
  
      return ($x, $y, 'PCD');
  }
  
  # swfmxsize: determine size of compressed ShockWave/Flash MX files. Adapted
  # from code sent by Victor Kuriashkin <victor@yasp.com>
  sub swfmxsize
  {
      my $image = shift;
  
      my $retval = eval {
          local $SIG{__DIE__} = q{};
          require Compress::Zlib;
          1;
      };
      if (! $retval)
      {
          return (undef, undef, "Error loading Compress::Zlib: $@");
      }
  
      my $header = $READ_IN->($image, 1058);
      my $ver = _bin2int(unpack 'B8', substr $header, 3, 1);
  
      my ($d, $status) = Compress::Zlib::inflateInit();
      $header = substr $header, 8, 1024;
      $header = $d->inflate($header);
  
      my $bs = unpack 'B133', substr $header, 0, 17;
      my $bits = _bin2int(substr $bs, 0, 5);
      my $x = int _bin2int(substr $bs, 5+$bits, $bits)/20;
      my $y = int _bin2int(substr $bs, 5+$bits*3, $bits)/20;
  
      return ($x, $y, 'CWS');
  }
  
  # Windows EMF files, requested by Jan v/d Zee
  sub emfsize
  {
      my $image = shift;
  
      my ($x, $y);
      my $buffer = $READ_IN->($image, 24);
  
      my ($topleft_x, $topleft_y, $bottomright_x, $bottomright_y) =
          unpack 'x8V4', $buffer;
  
      # The four values describe a box *around* the image, not *of* the image.
      # In other words, the dimensions are not inclusive.
      $x = $bottomright_x - $topleft_x - 1;
      $y = $bottomright_y - $topleft_y - 1;
  
      return ($x, $y, 'EMF');
  }
  
  # WEBP files, see https://developers.google.com/speed/webp/docs/riff_container
  # Added by Baldur Kristinsson, github.com/bk
  sub webpsize {
      my $img = shift;
  
      # There are 26 bytes of lead-in, before the width and height info:
      # 1. WEBP container
      #    - 'RIFF', 4 bytes
      #    - filesize, 4 bytes
      #    - 'WEBP', 4 bytes
      # 2. VP8 frame
      #    - 'VP8', 3 bytes
      #    - frame meta, 8 bytes
      #    - marker, 3 bytes
      my $buf = $READ_IN->($img, 4, 26);
      my ($raw_w, $raw_h) = unpack 'SS', $buf;
      my $b14 = 2**14 - 1;
  
      # The width and height values contain a 2-bit scaling factor,
      # which is left-shifted by 14 bits. We ignore this, since it seems
      # not to be relevant for our purposes. WEBP images in actual use
      # all seem to have a scaling factor of 0, anyway. (The meaning
      # of the scaling factor is as follows: 0=no upscale, 1=upscale by 5/4,
      # 2=upscale by 5/3, 3=upscale by 2).
      #
      # my $wscale = $raw_w >> 14;
      # my $hscale = $raw_h >> 14;
      my $x = $raw_w & $b14;
      my $y = $raw_h & $b14;
  
      return ($x, $y, 'WEBP');
  }
  
  # ICO files, originally contributed by Thomas Walloschke <thw@cpan.org>,
  # see https://rt.cpan.org/Public/Bug/Display.html?id=46279
  # (revised by Baldur Kristinsson, github.com/bk)
  sub icosize {
      my $img = shift;
      my ($x, $y) = unpack 'CC', $READ_IN->($img, 2, 6);
      if ($x == 0) { $x = 256; }
      if ($y == 0) { $y = 256; }
      return ($x, $y, 'ICO');
  }
  
  # CUR files, originally contributed by Thomas Walloschke <thw@cpan.org>,
  # see https://rt.cpan.org/Public/Bug/Display.html?id=46279
  # (revised by Baldur Kristinsson, github.com/bk)
  sub cursize {
      my ($x, $y, $ico) = icosize(shift);
      return ($x, $y, 'CUR');
  }
  
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Image::Size - read the dimensions of an image in several popular formats
  
  =head1 SYNOPSIS
  
      use Image::Size;
      # Get the size of globe.gif
      ($globe_x, $globe_y) = imgsize("globe.gif");
      # Assume X=60 and Y=40 for remaining examples
  
      use Image::Size 'html_imgsize';
      # Get the size as 'width="X" height="Y"' for HTML generation
      $size = html_imgsize("globe.gif");
      # $size == 'width="60" height="40"'
  
      use Image::Size 'attr_imgsize';
      # Get the size as a list passable to routines in CGI.pm
      @attrs = attr_imgsize("globe.gif");
      # @attrs == ('-width', 60, '-height', 40)
  
      use Image::Size;
      # Get the size of an in-memory buffer
      ($buf_x, $buf_y) = imgsize(\$buf);
      # Assuming that $buf was the data, imgsize() needed a
      $ reference to a scalar
  
  =head1 DESCRIPTION
  
  The B<Image::Size> library is based upon the C<wwwis> script written by
  Alex Knowles I<(alex@ed.ac.uk)>, a tool to examine HTML and add 'width' and
  'height' parameters to image tags. The sizes are cached internally based on
  file name, so multiple calls on the same file name (such as images used
  in bulleted lists, for example) do not result in repeated computations.
  
  =head1 SUBROUTINES/METHODS
  
  B<Image::Size> provides three interfaces for possible import:
  
  =over
  
  =item imgsize(I<stream>)
  
  Returns a three-item list of the X and Y dimensions (width and height, in
  that order) and image type of I<stream>. Errors are noted by undefined
  (B<undef>) values for the first two elements, and an error string in the third.
  The third element can be (and usually is) ignored, but is useful when
  sizing data whose type is unknown.
  
  =item html_imgsize(I<stream>)
  
  Returns the width and height (X and Y) of I<stream> pre-formatted as a single
  string C<'width="X" height="Y"'> suitable for addition into generated HTML IMG
  tags. If the underlying call to C<imgsize> fails, B<undef> is returned. The
  format returned is dually suited to both HTML and XHTML.
  
  =item attr_imgsize(I<stream>)
  
  Returns the width and height of I<stream> as part of a 4-element list useful
  for routines that use hash tables for the manipulation of named parameters,
  such as the Tk or CGI libraries. A typical return value looks like
  C<("-width", X, "-height", Y)>. If the underlying call to C<imgsize> fails,
  B<undef> is returned.
  
  =back
  
  By default, only C<imgsize()> is exported. Any one or combination of the three
  may be explicitly imported, or all three may be with the tag B<:all>.
  
  =head2 Input Types
  
  The sort of data passed as I<stream> can be one of three forms:
  
  =over
  
  =item string
  
  If an ordinary scalar (string) is passed, it is assumed to be a file name
  (either absolute or relative to the current working directory of the
  process) and is searched for and opened (if found) as the source of data.
  Possible error messages (see DIAGNOSTICS below) may include file-access
  problems.
  
  =item scalar reference
  
  If the passed-in stream is a scalar reference, it is interpreted as pointing
  to an in-memory buffer containing the image data.
  
          # Assume that &read_data gets data somewhere (WWW, etc.)
          $img = &read_data;
          ($x, $y, $id) = imgsize(\$img);
          # $x and $y are dimensions, $id is the type of the image
  
  =item Open file handle
  
  The third option is to pass in an open filehandle (such as an object of
  the C<IO::File> class, for example) that has already been associated with
  the target image file. The file pointer will necessarily move, but will be
  restored to its original position before subroutine end.
  
          # $fh was passed in, is IO::File reference:
          ($x, $y, $id) = imgsize($fh);
          # Same as calling with filename, but more abstract.
  
  =back
  
  =head2 Recognized Formats
  
  Image::Size natively understands and sizes data in the following formats:
  
  =over 4
  
  =item GIF
  
  =item JPG
  
  =item XBM
  
  =item XPM
  
  =item PPM family (PPM/PGM/PBM)
  
  =item XV thumbnails
  
  =item PNG
  
  =item MNG
  
  =item TIF
  
  =item BMP
  
  =item PSD (Adobe PhotoShop)
  
  =item SWF (ShockWave/Flash)
  
  =item CWS (FlashMX, compressed SWF, Flash 6)
  
  =item PCD (Kodak PhotoCD, see notes below)
  
  =item EMF (Windows Enhanced Metafile Format)
  
  =item WEBP
  
  =item ICO (Microsoft icon format)
  
  =item CUR (Microsoft mouse cursor format)
  
  =back
  
  Additionally, if the B<Image::Magick> module is present, the file types
  supported by it are also supported by Image::Size.  See also L<"CAVEATS">.
  
  When using the C<imgsize> interface, there is a third, unused value returned
  if the programmer wishes to save and examine it. This value is the identity of
  the data type, expressed as a 2-3 letter abbreviation as listed above. This is
  useful when operating on open file handles or in-memory data, where the type
  is as unknown as the size.  The two support routines ignore this third return
  value, so those wishing to use it must use the base C<imgsize> routine.
  
  Note that when the B<Image::Magick> fallback is used (for all non-natively
  supported files), the data type identity comes directly from the 'format'
  parameter reported by B<Image::Magick>, so it may not meet the 2-3 letter
  abbreviation format.  For example, a WBMP file might be reported as
  'Wireless Bitmap (level 0) image' in this case.
  
  =head2 Information Caching and C<$NO_CACHE>
  
  When a filename is passed to any of the sizing routines, the default behavior
  of the library is to cache the resulting information. The modification-time of
  the file is also recorded, to determine whether the cache should be purged and
  updated. This was originally added due to the fact that a number of CGI
  applications were using this library to generate attributes for pages that
  often used the same graphical element many times over.
  
  However, the caching can lead to problems when the files are generated
  dynamically, at a rate that exceeds the resolution of the modification-time
  value on the filesystem. Thus, the optionally-importable control variable
  C<$NO_CACHE> has been introduced. If this value is anything that evaluates to a
  non-false value (be that the value 1, any non-null string, etc.) then the
  cacheing is disabled until such time as the program re-enables it by setting
  the value to false.
  
  The parameter C<$NO_CACHE> may be imported as with the B<imgsize> routine, and
  is also imported when using the import tag B<C<:all>>. If the programmer
  chooses not to import it, it is still accessible by the fully-qualified package
  name, B<$Image::Size::NO_CACHE>.
  
  =head2 Sharing the Cache Between Processes
  
  If you are using B<Image::Size> in a multi-thread or multi-process environment,
  you may wish to enable sharing of the cached information between the
  processes (or threads). Image::Size does not natively provide any facility
  for this, as it would add to the list of dependencies.
  
  To make it possible for users to do this themselves, the C<%CACHE> hash-table
  that B<Image::Size> uses internally for storage may be imported in the B<use>
  statement. The user may then make use of packages such as B<IPC::MMA>
  (L<IPC::MMA|IPC::MMA>) that can C<tie> a hash to a shared-memory segment:
  
      use Image::Size qw(imgsize %CACHE);
      use IPC::MMA;
  
      ...
  
      tie %CACHE, 'IPC::MM::Hash', $mmHash; # $mmHash via mm_make_hash
      # Now, forked processes will share any changes made to the cache
  
  =head2 Sizing PhotoCD Images
  
  With version 2.95, support for the Kodak PhotoCD image format is
  included. However, these image files are not quite like the others. One file
  is the source of the image in any of a range of pre-set resolutions (all with
  the same aspect ratio). Supporting this here is tricky, since there is nothing
  inherent in the file to limit it to a specific resolution.
  
  The library addresses this by using a scale mapping, and requiring the user
  (you) to specify which scale is preferred for return. Like the C<$NO_CACHE>
  setting described earlier, this is an importable scalar variable that may be
  used within the application that uses B<Image::Size>. This parameter is called
  C<$PCD_SCALE>, and is imported by the same name. It, too, is also imported
  when using the tag B<C<:all>> or may be referenced as
  B<$Image::Size::PCD_SCALE>.
  
  The parameter should be set to one of the following values:
  
          base/16
          base/4
          base
          base4
          base16
          base64
  
  Note that not all PhotoCD disks will have included the C<base64>
  resolution. The actual resolutions are not listed here, as they are constant
  and can be found in any documentation on the PCD format. The value of
  C<$PCD_SCALE> is treated in a case-insensitive manner, so C<base> is the same
  as C<Base> or C<BaSe>. The default scale is set to C<base>.
  
  Also note that the library makes no effort to read enough of the PCD file to
  verify that the requested resolution is available. The point of this library
  is to read as little as necessary so as to operate efficiently. Thus, the only
  real difference to be found is in whether the orientation of the image is
  portrait or landscape. That is in fact all that the library extracts from the
  image file.
  
  =head2 Controlling Behavior with GIF Images
  
  GIF images present a sort of unusual situation when it comes to reading size.
  Because GIFs can be a series of sub-images to be played as an animated
  sequence, what part does the user want to get the size for?
  
  When dealing with GIF files, the user may control the behavior by setting the
  global value B<$Image::Size::GIF_BEHAVIOR>. Like the PCD setting, this may
  be imported when loading the library. Three values are recognized by the
  GIF-handling code:
  
  =over 4
  
  =item Z<>0
  
  This is the default value. When this value is chosen, the returned dimensions
  are those of the "screen". The "screen" is the display area that the GIF
  declares in the first data block of the file. No sub-images will be greater
  than this in size; if they are, the specification dictates that they be
  cropped to fit within the box.
  
  This is also the fastest method for sizing the GIF, as it reads the least
  amount of data from the image stream.
  
  =item Z<>1
  
  If this value is set, then the size of the first sub-image within the GIF is
  returned. For plain (non-animated) GIF files, this would be the same as the
  screen (though it doesn't have to be, strictly-speaking).
  
  When the first image descriptor block is read, the code immediately returns,
  making this only slightly-less efficient than the previous setting.
  
  =item Z<>2
  
  If this value is chosen, then the code loops through all the sub-images of the
  animated GIF, and returns the dimensions of the largest of them.
  
  This option requires that the full GIF image be read, in order to ensure that
  the largest is found.
  
  =back
  
  Any value outside this range will produce an error in the GIF code before any
  image data is read.
  
  The value of dimensions other than the view-port ("screen") is dubious.
  However, some users have asked for that functionality.
  
  =head1 Image::Size AND WEBSERVERS
  
  There are a few approaches to getting the most out of B<Image::Size> in a
  multi-process webserver environment. The two most common are pre-caching and
  using shared memory. These examples are focused on Apache, but should be
  adaptable to other server approaches as well.
  
  =head2 Pre-Caching Image Data
  
  One approach is to include code in an Apache start-up script that reads the
  information on all images ahead of time. A script loaded via C<PerlRequire>,
  for example, becomes part of the server memory before child processes are
  created. When the children are created, they come into existence with a
  pre-primed cache already available.
  
  The shortcoming of this approach is that you have to plan ahead of time for
  which image files you need to cache. Also, if the list is long-enough it
  can slow server start-up time.
  
  The advantage is that it keeps the information centralized in one place and
  thus easier to manage and maintain. It also requires no additional CPAN
  modules.
  
  =head2 Shared Memory Caching
  
  Another approach is to introduce a shared memory segment that the individual
  processes all have access to. This can be done with any of a variety of
  shared memory modules on CPAN.
  
  Probably the easiest way to do this is to use one of the packages that allow
  the tying of a hash to a shared memory segment. You can use this in
  combination with importing the hash table variable that is used by
  B<Image::Size> for the cache, or you can refer to it explicitly by full
  package name:
  
      use IPC::Shareable;
      use Image::Size;
  
      tie %Image::Size::CACHE, 'IPC::Shareable', 'size', { create => 1 };
  
  That example uses B<IPC::Shareable> (see L<IPC::Shareable|IPC::Shareable>) and
  uses the option to the C<tie> command that tells B<IPC::Shareable> to create
  the segment. Once the initial server process starts to create children, they
  will all share the tied handle to the memory segment.
  
  Another package that provides this capability is B<IPC::MMA> (see
  L<IPC::MMA|IPC::MMA>), which provides shared memory management via the I<mm>
  library from Ralf Engelschall (details available in the documentation for
  B<IPC::MMA>):
  
      use IPC::MMA;
      use Image::Size qw(%CACHE);
  
      my $mm = mm_create(65536, '/tmp/test_lockfile');
      my $mmHash = mm_make_hash($mm);
      tie %CACHE, 'IPC::MM::Hash', $mmHash;
  
  As before, this is done in the start-up phase of the webserver. As the
  child processes are created, they inherit the pointer to the existing shared
  segment.
  
  =head1 MORE EXAMPLES
  
  The B<attr_imgsize> interface is also well-suited to use with the Tk
  extension:
  
      $image = $widget->Photo(-file => $img_path, attr_imgsize($img_path));
  
  Since the C<Tk::Image> classes use dashed option names as C<CGI> does, no
  further translation is needed.
  
  This package is also well-suited for use within an Apache web server context.
  File sizes are cached upon read (with a check against the modified time of
  the file, in case of changes), a useful feature for a B<mod_perl> environment
  in which a child process endures beyond the lifetime of a single request.
  Other aspects of the B<mod_perl> environment cooperate nicely with this
  module, such as the ability to use a sub-request to fetch the full pathname
  for a file within the server space. This complements the HTML generation
  capabilities of the B<CGI> module, in which C<CGI::img> wants a URL but
  C<attr_imgsize> needs a file path:
  
      # Assume $Q is an object of class CGI, $r is an Apache request object.
      # $imgpath is a URL for something like "/img/redball.gif".
      $r->print($Q->img({ -src => $imgpath,
                          attr_imgsize($r->lookup_uri($imgpath)->filename) }));
  
  The advantage here, besides not having to hard-code the server document root,
  is that Apache passes the sub-request through the usual request lifecycle,
  including any stages that would re-write the URL or otherwise modify it.
  
  =head1 DIAGNOSTICS
  
  The base routine, C<imgsize>, returns B<undef> as the first value in its list
  when an error has occurred. The third element contains a descriptive
  error message.
  
  The other two routines simply return B<undef> in the case of error.
  
  =head1 CAVEATS
  
  Caching of size data can only be done on inputs that are file names. Open
  file handles and scalar references cannot be reliably transformed into a
  unique key for the table of cache data. Buffers could be cached using the
  MD5 module, and perhaps in the future I will make that an option. I do not,
  however, wish to lengthen the dependency list by another item at this time.
  
  As B<Image::Magick> operates on file names, not handles, the use of it is
  restricted to cases where the input to C<imgsize> is provided as file name.
  
  =head1 SEE ALSO
  
  L<Image::Magick|Image::Magick> and L<Image::Info|Image::Info> Perl modules at
  CPAN. The B<Graphics::Magick> Perl API at
  L<http://www.graphicsmagick.org/perl.html>.
  
  =head1 CONTRIBUTORS
  
  Perl module interface by Randy J. Ray I<(rjray@blackperl.com)>, original
  image-sizing code by Alex Knowles I<(alex@ed.ac.uk)> and Andrew Tong
  I<(werdna@ugcs.caltech.edu)>, used with their joint permission.
  
  Some bug fixes submitted by Bernd Leibing I<(bernd.leibing@rz.uni-ulm.de)>.
  PPM/PGM/PBM sizing code contributed by Carsten Dominik
  I<(dominik@strw.LeidenUniv.nl)>. Tom Metro I<(tmetro@vl.com)> re-wrote the JPG
  and PNG code, and also provided a PNG image for the test suite. Dan Klein
  I<(dvk@lonewolf.com)> contributed a re-write of the GIF code.  Cloyce Spradling
  I<(cloyce@headgear.org)> contributed TIFF sizing code and test images. Aldo
  Calpini I<(a.calpini@romagiubileo.it)> suggested support of BMP images (which
  I I<really> should have already thought of :-) and provided code to work
  with. A patch to allow html_imgsize to produce valid output for XHTML, as
  well as some documentation fixes was provided by Charles Levert
  I<(charles@comm.polymtl.ca)>. The ShockWave/Flash support was provided by
  Dmitry Dorofeev I<(dima@yasp.com)>. Though I neglected to take note of who
  supplied the PSD (PhotoShop) code, a bug was identified by Alex Weslowski
  <aweslowski@rpinteractive.com>, who also provided a test image. PCD support
  was adapted from a script made available by Phil Greenspun, as guided to my
  attention by Matt Mueller I<mueller@wetafx.co.nz>. A thorough read of the
  documentation and source by Philip Newton I<Philip.Newton@datenrevision.de>
  found several typos and a small buglet. Ville Skyttï¿½ I<(ville.skytta@iki.fi)>
  provided the MNG and the Image::Magick fallback code. Craig MacKenna
  I<(mackenna@animalhead.com)> suggested making the cache available so that it
  could be used with shared memory, and helped test my change before release.
  
  =head1 BUGS
  
  Please report any bugs or feature requests to
  C<bug-image-size at rt.cpan.org>, or through the web interface at
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Image-Size>. I will be
  notified, and then you'll automatically be notified of progress on
  your bug as I make changes.
  
  =head1 SUPPORT
  
  =over 4
  
  =item * RT: CPAN's request tracker
  
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Image-Size>
  
  =item * AnnoCPAN: Annotated CPAN documentation
  
  L<http://annocpan.org/dist/Image-Size>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/d/Image-Size>
  
  =item * Search CPAN
  
  L<http://search.cpan.org/dist/Image-Size>
  
  =item * Project page on GitHub
  
  L<http://github.com/rjray/image-size>
  
  =back
  
  =head1 REPOSITORY
  
  L<https://github.com/rjray/image-size>
  
  =head1 LICENSE AND COPYRIGHT
  
  This file and the code within are copyright (c) 1996-2009 by Randy J. Ray.
  
  Copying and distribution are permitted under the terms of the Artistic
  License 2.0 (L<http://www.opensource.org/licenses/artistic-license-2.0.php>) or
  the GNU LGPL 2.1 (L<http://www.opensource.org/licenses/lgpl-2.1.php>).
  
  =head1 AUTHOR
  
  Randy J. Ray C<< <rjray@blackperl.com> >>
  
  =cut
IMAGE_SIZE

$fatpacked{"Photography/Website.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PHOTOGRAPHY_WEBSITE';
  package Photography::Website;
  use strict;
  use warnings;
  use feature 'say';
  
  use Photography::Website::Configure;
  use DateTime;
  use File::Path            qw(make_path remove_tree);
  use File::Basename        qw(basename dirname);
  use File::ShareDir::PAR   qw(dist_file dist_dir);
  use File::Spec::Functions qw(catfile catdir);
  use File::Copy::Recursive qw(dircopy);
  use Image::Size           qw(imgsize);
  use Image::ExifTool       qw(ImageInfo);
  use String::Random        qw(random_regex);
  use Algorithm::Numerical::Shuffle qw(shuffle);
  use Template; my $tt = Template->new({ABSOLUTE => 1});
  
  our $silent  = 0;
  our $verbose = 0;
  
  =head1 NAME
  
  Photography::Website
  
  =head1 SYNOPSIS
  
      use Photography::Website;
  
      my $source      = "$ENV{HOME}/Pictures";
      my $destination = "$ENV{HOME}/public_html";
  
      # Process the pictures tree
      my $website = Photography::Website::create_album($source);
  
      # Generate the website
      Photography::Website::generate($website);
  
  =head1 DESCRIPTION
  
  The Photography::Website module contains the core of the Photog!
  photography website generator. Please refer to photog(3) for a more
  general introduction on how to run Photog! and how to configure
  it. All of the configuration options are documented in
  Photography::Website::Configure(1). If you want to learn about the
  internals of Photog!, read on.
  
  A photography website is generated in two stages. The first stage
  searches the source directory tree for images and optional
  C<photog.ini> files, and processes them into a data structure of
  nested albums. An album is simply a hash of configuration variables
  one of which ($album->{items}) references a list of further
  hashes. This stage is kicked off by the create_album() function.
  
  The second stage loops through this data structure, compares all the
  sources with their destinations, and (re)generates them if needed. It
  builds a website with nested album pages that contain image thubmnails
  and album preview thumbnails. The structure of album pages mirrors the
  structure of the source image directory. This process is started with
  the generate() function.
  
  =head1 FUNCTIONS
  
  =over
  
  =item B<create_album>(I<$source>[, I<$parent>])
  
  The main entry point for creating a website structure. $source should
  be a directory name, $parent is only used when this function is called
  recursively. Returns an album with nested sub-albums that represents
  the source directory tree.
  
  =cut
  
  sub create_album {
      my $source = shift;
      my $parent = shift; # optional
      my $album  = Photography::Website::Configure::album($source, $parent) || return;
  
      for (list($source)) {
          my $item;
          if (-f) {
              $item = Photography::Website::Configure::image($_, $album) || next;
          }
          elsif (-d) {
              $item = create_album($_, $album) || next;
          }
          $album->{allfiles}->{$item->{destination}} = 1;
          $album->{allfiles}->{$item->{thumbnail}} = 1;
          push @{$album->{items}}, $item;
      }
      return $album;
  }
  
  =item B<generate>(I<$album>)
  
  The second main entry point that generates the actual website images
  and HTML files at the destinations specified inside the $album data
  structure. Returns nothing.
  
  =cut
  
  sub generate {
      my $album    = shift;
      my $outdated = 0;
  
      # Copy static files to destination root
      if (not $album->{parent}) {
          push @{$album->{protected}}, 'static';
          my $static_source = catdir(dist_dir('Photog'), 'static');
          my $static_destination = catdir($album->{destination}, 'static');
          dircopy($static_source, $static_destination) and say "/static/";
      }
  
      # Recursively update image files and album pages
      for my $item (@{$album->{items}}) {
          if ($item->{type} eq 'image') {
              if (update_image($item)) {
                  $outdated = 1;
              }
          }
          elsif ($item->{type} eq 'album') {
              if (generate($item, $album) and not $item->{unlisted}) {
                  $outdated = 1;
              }
          }
      }
  
      return update_album($album, $outdated);
  }
  
  =item B<update_image>(I<$image>[, I<$force>])
  
  Given an $image node, checks if the image source is newer than the
  destination. If needed, or if $force is true, it builds new
  destination files. Returns true if any images have been (re)generated.
  
  =cut
  
  sub update_image {
      my $img           = shift;
      my $update_needed = shift || (
          not -f $img->{destination} or
          not -f $img->{thumbnail} or
          is_newer($img->{source}, $img->{destination})
      );
  
      if ($update_needed) {
          build_image($img);
          return 1;
      }
      else {
          return 0;
      }
  }
  
  =item B<update_album>(I<$album>[, I<$force>])
  
  Given an $album node, first deletes any destination files that don't
  have a corresponding source. Then it (re)builds the album's preview
  and index if an update is needed or if $force is true. Returns true
  if any changes have been made at the destination directory.
  
  =cut
  
  sub update_album {
      my $album         = shift;
      my $update_needed = shift || ( # optional
          not -f $album->{index} or
          (not -f $album->{thumbnail} and not $album->{unlisted}) or
          is_newer($album->{config}, $album->{thumbnail})
      );
  
      if (not -d $album->{destination}) {
          make_path($album->{destination});
      }
  
      # Delete all destinations that do not appear in the allfiles hash, unless they are protected
      for my $dest (list($album->{destination}), list(catdir($album->{destination}, 'thumbnails'))) {
          my $file = basename($dest);
          if (not exists $album->{allfiles}->{$dest}) {
              if (not grep {$_ eq $file} @{$album->{protected}}) {
                  say "Removing $dest" unless $silent;
                  remove_tree($dest);
                  $update_needed = 1;
              }
          }
      }
  
      if ($update_needed) {
          build_preview($album) unless $album->{unlisted};
          build_index($album);
      }
  
      return $update_needed;
  }
  
  =item B<build_image>(I<$image>)
  
  Builds the image's destination files, by shelling out to the the
  watermark or scale and thumbnail commands.
  
  =cut
  
  sub build_image {
      my $img = shift;
      say $img->{url} unless $silent;
      make_path(dirname($img->{destination}));
      if ($img->{watermark}) {
          system($img->{watermark_command},
                 $img->{source},
                 $img->{watermark},
                 $img->{destination},
             ) and die "ERROR: Watermark command failed\n";
      }
      else {
          system($img->{scale_command},
                 $img->{source},
                 $img->{destination},
             ) and die "ERROR: Scale command failed\n";
      }
      make_path(dirname($img->{thumbnail}));
      system($img->{thumbnail_command},
             $img->{source},
             $img->{thumbnail},
         ) and die "ERROR: Thumbnail command failed\n";
  }
  
  =item B<build_index>(I<$album>)
  
  Given an $album node, builds an album preview image and the album's
  C<index.html> after sorting the album's images according to Exif
  dates.
  
  =cut
  
  sub build_index {
      my $album = shift;
  
      # This defines a function named 'root' to be used in templates to
      # calculate the relative pathname to the website root (which
      # ensures that the website can be viewed by a browser locally)
      my $rel = $album->{url};
      $rel =~ s:[^/]+/:\.\./:g;
      $rel =~ s:^/::;
      $album->{root} = sub { $rel.$_[0] };
  
      # Calculate and store image sizes and dates
      for (@{$album->{items}}) {
          ($_->{width}, $_->{height}) = imgsize($_->{thumbnail});
          if ($_->{type} eq 'image') {
              $_->{date} = exifdate($_->{source});
          }
      }
  
      @{$album->{items}} = sort {
          return $a->{date} cmp $b->{date} if $album->{sort} eq 'ascending';
          return $b->{date} cmp $a->{date} if $album->{sort} eq 'descending';
      } @{$album->{items}};
  
      say $album->{url} . "index.html";
      $tt->process($album->{template}, $album, $album->{index})
          || die $tt->error();
  }
  
  =item B<create_preview>(I<$album>)
  
  Creates an album preview image by making a random selection of the
  album's images and calling the C<photog-preview> command.
  
  =cut
  
  sub build_preview {
      my $album  = shift;
  
      my @images = select_images($album);
      my $size = scalar @images;
      if ($size < 3) {
          say "WARNING: Not enough images available in '$album->{name}' to create a preview";
          return;
      }
      elsif ($size < $album->{preview}) {
          say "WARNING: Only $size preview images available for '$album->{name}' ($album->{preview} requested)" unless $silent;
          $album->{preview} = $size;
      }
  
      # Round the number of preview images down to 3, 6, or 9
      $album->{preview}-- until grep {$_ == $album->{preview}} (3, 6, 9);
  
      # Shuffle the list and pick N preview images
      @images = @{[shuffle @images]}[0..($album->{preview})-1];
  
      make_path(dirname($album->{thumbnail}));
      system($album->{preview_command},
             @images,
             $album->{thumbnail},
         ) and die "ERROR: Preview command failed\n";
  }
  
  =item B<select_images>(I<$album>)
  
  Returns a list of image paths that are eligible for inclusion in an
  album preview. It makes sure that the list only contains images whose
  filename does not appear in the parent album. The reason for this is
  that the author of Photog! likes to show the best photographs from an
  album on the front page, but not also have those photographs included
  in an album preview.
  
  =cut
  
  sub select_images {
      my $album  = shift;
      if ($album->{parent}) {
  
          # Read the following lines from end to beginning
          my %excl = map {$_ => 1}
              map {$_->{href}}
              grep {$_->{type} eq 'image'}
              @{$album->{parent}->{items}};
  
          return map {$_->{thumbnail}}
              grep {not $excl{$_->{href}}}
              grep { $_->{type} eq 'image' }
              @{$album->{items}};
      }
      else {
          return map {$_->{thumbnail}} @{$album->{items}};
      }
  }
  
  =item B<list>(I<$dir>)
  
  Returns a list of absolute pathnames to all the files and directories
  inside $dir.
  
  =cut
  
  sub list {
      my $dir = shift;
      my @files;
      my @dirs;
      opendir(my $dh, $dir) or return ();
      while (readdir $dh) {
          next if /^\./;
          push @files, "$dir/$_" if -f "$dir/$_";
          push @dirs, "$dir/$_" if -d "$dir/$_";
      }
      sub alphabetical { lc($a) cmp lc($b) }
      @files = sort alphabetical @files;
      @dirs = sort alphabetical @dirs;
      return @dirs, @files;
  }
  
  =item B<is_newer>(I<$file1>, I<$file2>)
  
  Determines the modification times of $file1 and $file2 (which should
  pathnames). It both files exist and $file1 is newer than $file2, it
  returns true. Beware: if both files are of the same age, $file1 is not
  newer than $file2.
  
  =cut
  
  sub is_newer {
      my $file1 = shift;
      my $file2 = shift;
      return unless -f $file1 and -f $file2;
      my $time1 = (stat $file1)[9];
      my $time2 = (stat $file2)[9];
      return $time1 > $time2;
  }
  
  =item B<exifdate>(I<$file>)
  
  Extracts the value of the Exif tag C<DateTimeOriginal> from the
  provided image path, converts it to ISO 8601 format, and returns
  it. Prints a warning and returns 0 if the Exif tag could not be found.
  
  =cut
  
  sub exifdate {
      my $file = shift or die;
      my $exif = ImageInfo($file, 'DateTimeOriginal');
      if (not $exif->{DateTimeOriginal}) {
          say "WARNING: Exif tag 'DateTimeOriginal' missing from '$file'";
          return 0;
      }
      my ($date, $time) = split(/ /, $exif->{DateTimeOriginal});
      $date =~ s/:/-/g;
      return $date . 'T' . $time;
  }
  
  =back
  
  =head1 SEE ALSO
  
  photog(3), Photography::Website::Configuration(1)
  
  =head1 AUTHOR
  
  Photog! was written by Jaap Joris Vens <jj@rtts.eu>, and is used to
  create his personal photography website at http://www.superformosa.nl/
  
  
  =cut
  
  1;
PHOTOGRAPHY_WEBSITE

$fatpacked{"Photography/Website/Configure.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PHOTOGRAPHY_WEBSITE_CONFIGURE';
  package Photography::Website::Configure;
  use warnings;
  use strict;
  
  use DateTime;
  use File::Basename        qw(basename dirname);
  use File::ShareDir::PAR   qw(dist_file dist_dir);
  use File::Spec::Functions qw(catfile);
  use Config::General       qw(ParseConfig);
  use String::Random        qw(random_regex);
  
  my $CONFIG_FILE = "photog.ini";
  
  =head1 NAME
  
  Photography::Website::Configure
  
  =head1 DESCRIPTION
  
  This module contains the configuration logic of Photog! the
  photography website generator. See photog(3) for the documentation
  about the command-line interface and see Photography::Website(1) for
  documentation about the Perl interface.
  
  What follows is a comprehensive list of all configuration options
  currently in use, with a short description of their usage and their
  default value.
  
  =head2 Image variables
  
  =over 12
  
  =cut
  
  sub image {
      my $source = shift;
      my $parent = shift;
      return if not is_image($source);
      my $img = {
          type   => 'image',
          parent => $parent,
      };
      my $filename = basename($source);
  
  =item B<name>
  
  The image filename without the extension. Is used by the default
  template as the caption when the image is viewed fullscreen.
  
  =cut
  
      $img->{name}   = strip_suffix($filename);
  
  =item B<url>
  
  The absolute URL of the fullscreen image. This is used to calculate
  the image destination. Templates should use the relative URL (see next).
  
  =cut
  
      $img->{url}    = $parent->{url} . $filename;
  
  =item B<href>
  
  The relative URL of the full-size image, i.e., the image filename.
  
  =cut
  
      $img->{href}   = $filename;
  
  =item B<src>
  
  The relative URL of the image thumbnail, i.e., C<thumbnails/$filename>.
  
  =cut
  
      $img->{src}    = "thumbnails/$filename";
  
  =item B<source>
  
  The full path to the original image in the source directory.
  
  =cut
  
      $img->{source} = $source;
  
  =item B<destination>
  
  The full path to the fullscreen image in the destination directory.
  
  =cut
  
      $img->{destination} = catfile($parent->{root}, substr($img->{url}, 1));
  
  =item B<thumbnail>
  
  The path to the image thumbnail.
  
  =cut
  
      $img->{thumbnail} = catfile($parent->{destination}, $img->{src});
  
  
      # These are documented further below
      $img->{watermark}         = $parent->{watermark};
      $img->{scale_command}     = $parent->{scale_command};
      $img->{watermark_command} = $parent->{watermark_command};
      $img->{thumbnail_command} = $parent->{thumbnail_command};
      return $img;
  }
  
  =back
  
  =head2 Album variables
  
  There are three types of album configuration variables: static variables,
  dynamic variables, and inherited variables. Static variables cannot be
  changed from a configuration file. Dynamic variables can be set in a
  configuration or they are calculated dynamically. Inherited variables
  are either set from a configuration file, inherited from the parent,
  or a default value.
  
  =over 12
  
  =cut
  
  sub album {
      my $source = shift;
      my $parent = shift; # optional
      my $album  = get_config($source);
  
      # Special case for root albums
      # $parent = $album if not $parent;
  
      # Implementation of the "oblivious" feature
      if (not $album) {
          return if $parent->{oblivious};
          $album = {};
      }
  
      # Implementation of the "private" feature
      if (defined $album->{slug} and $album->{slug} eq 'private') {
          $album->{slug} = random_regex('[1-9][a-hjkp-z2-9]{15}');
          $album->{unlisted} = "true";
          save_config($album, $source);
      }
  
      $album->{type} = 'album';
      $album->{parent} = $parent;
  
      # Instantiate the global allfiles hash
      if (not $parent) {
          $album->{allfiles} = {};
      }
      else {
          $album->{allfiles} = $parent->{allfiles};
      }
  
  
  =item I<Static variables>
  
  =item B<source>
  
  The source directory.
  
  =cut
  
      $album->{source} = $source;
  
  =item B<config>
  
  Path to the album's C<photog.ini>
  
  =cut
  
      $album->{config} = catfile($source, $CONFIG_FILE);
  
  =item B<name>
  
  Directory basename of the album, currently only used for debugging
  purposes.
  
  =cut
  
      $album->{name} = basename($source);
  
  =item B<root>
  
  The destination directory of the root album. This is always inherited
  from the parent album.
  
  =cut
  
      if ($parent) {
          $album->{root} = $parent->{root};
      }
      else {
          $album->{root} = $album->{destination} || die
              "ERROR: Destination not specified";
      }
  
  =item I<Dynamic variables>
  
  =item B<slug>
  
  A slug is the part of the URL that identifies an album,
  e.g. C<www.example.com/slug/>. The default value is the directory's
  name, so be careful not to use characters in directory names that are
  not allowed in URLs, like spaces. Or, simply override this value to
  choose an appropriate URL for each album.
  
  The special value of "private" will cause a random slug to be
  generated consisting of 16 alphanumeric characters, which will
  immediately be saved to the C<photog.ini> file, replacing the
  original "private" value. In addition, the variable B<unlisted>
  will be set to true. Use this for creating private albums that
  are only accessible to people who know the secret URL.
  
  =cut
  
      $album->{slug} ||= basename($source);
  
  =item B<url>
  
  Calculated by concatenating the parent url and the album slug.
  Overriding this option allows the source directories to be differently
  organized than the destination directories.
  
  =cut
  
      $album->{url} ||= $parent->{url}
          ? "$parent->{url}$album->{slug}/"
          : "/";
  
  =item B<href>
  
  The album link for use inside the <a> tag in the template.
  
  =cut
  
      $album->{href} ||= $album->{slug} . '/';
  
  =item B<src>
  
  The album preview image for use inside the <img> tag in the
  template. Width and height will also be made available to the
  template.
  
  =cut
  
      $album->{src} ||= $album->{href} . "thumbnails/all.jpg";
  
  =item B<destination>
  
  The album's destination directory. Calculated by concatenating the
  root destination directory and the album's URL. Although possible,
  overriding this option for subdirectories is not recommended. Use the
  B<url> option instead (see above).
  
  =cut
  
      $album->{destination} ||=
          catfile($album->{root}, substr($album->{url}, 1));
  
  =item B<thumbnail>
  
  Path to the album preview image, for use a thumbnail in the parent
  album. Defaults to the file C<all.jpg> in subdirectory C<thumbnails>
  inside the destination directory.
  
  =cut
  
      $album->{thumbnail} ||=
          catfile($album->{destination}, "thumbnails/all.jpg");
  
  =item B<index>
  
  Path to to the album's C<index.html>.
  
  =cut
  
      $album->{index} ||=
          catfile($album->{destination}, "index.html");
  
  =item B<unlisted>
  
  Boolean value that specifies whether this album will be diplayed on
  the parent album. The album page remains accessible to people who know
  the URL. Defaults to C<false>.  Not inherited, always defaults to
  false (except for the root album)
  
  =cut
  
      $album->{unlisted} ||= (not defined $album->{parent});
  
  =item B<date>
  
  The ISO 8601 date and optionally time of this album. This is used when
  sorting items chronologically. The default is the directory's
  modification date. The default template never actually shows dates,
  but it can also be used to determine the placement of album previews
  on a page.
  
  =cut
  
      $album->{date} ||= DateTime->from_epoch(
          epoch => (stat $source)[9]);
  
  =item B<protected>
  
  A list of filenames that will not be automatically deleted at the
  album's destination directory. Defaults to ('index.html',
  'thumbnails'). The root album will also get the directory 'static'
  appended to this list.
  
  =cut
  
      if (not exists $album->{protected}) {
          $album->{protected} = [];
      }
      push @{$album->{protected}}, ('index.html', 'thumbnails');
  
  =item I<Inherited variables>
  
  =item B<title>
  
  In the default template, the title appears at the top of the page. The
  default value is "My Photography Website". Please set this to
  something more catchy. You can also override it for specific albums to
  show an album name.
  
  =cut
  
      if (not exists $album->{title}) {
          $album->{title} = $parent->{title}
              || "My Photography Website";
      }
  
  =item B<copyright>
  
  In the default template, the copyright notice appears at the
  bottom of the page. The default value is empty.
  
  =cut
  
      if (not exists $album->{copyright}) {
          $album->{copyright} = $parent->{copyright} || '';
      }
  
  =item B<template>
  
  Path to an HTML file containing directives in Template::Toolkit
  syntax. The current album will be made available as the variable
  "album", from where all additional configuration variables can be
  accessed using dot syntax, i.e., album.title, album.copyright etc. You
  can even make up your own configuration variables in C<photog.ini> and
  have them available in the template. The default is the file
  C<template.html> that's included with Photog!. Use it as a starting
  point to create your own template!
  
  =cut
  
      $album->{template} ||= $parent->{template}
                         || dist_file('Photog', 'template.html');
  
  =item B<preview>
  
  An album preview is a thumbnail image of the album that contains a
  number of smaller images. This option sets the number of preview
  images for an album. Allowed values are 3, 6, and 9. The default is 9.
  
  =cut
  
      $album->{preview} ||= $parent->{preview} || 9;
  
  =item B<watermark>
  
  The path to a transparent PNG file that will be used to watermark all
  fullscreen images in an album. The command C<photog-watermark> is
  called to do the actual watermarking, and it currently places the
  watermark in the lower right corner. The default is to not watermark
  website images.
  
  =cut
  
      if (not exists $album->{watermark}) {
          $album->{watermark} = $parent->{watermark} || '';
      }
  
  =item B<sort>
  
  Photos are always sorted according to EXIF date. Possible sort orders
  are: C<ascending> and C<descending>. The default value is
  C<descending>.
  
  =cut
  
      $album->{sort} ||= $parent->{sort} || 'descending';
  
  =item B<fullscreen>
  
  A boolean to indicate whether large images should be made
  available. Use this to prevent access to full-size images by clients
  who haven't paid yet. Defaults to true.
  
  =cut
  
      if (not exists $album->{fullscreen}) {
          if ($album->{parent}) {
              $album->{fullscreen} = $parent->{fullscreen};
          }
          else {
              $album->{fullscreen} = 1;
          }
      }
  
  =item B<oblivious>
  
  A boolean value that specifies whether C<photog.ini>
  files are required. If true, Photog! will only consider a
  subdirectory an album when it contains a C<photog.ini> file, even if
  the file is empty. Defaults to false.
  
  =cut
  
      if (not exists $album->{oblivious}) {
          $album->{oblivious} = $parent->{oblivious} || 0;
      }
  
  =item B<scale_command>
  
  The path to a command to convert an original image to a fullscreen
  web-image. The command will receive 2 arguments: The source image path
  and the destination image path. The default is C<photog-scale>, which
  will scale an image to measure 2160 pixels vertically.
  
  =cut
  
      $album->{scale_command} ||= $parent->{scale_command}
                              || 'photog-scale';
  
  =item B<watermark_command>
  
  The command that does the image watermarking. The command will receive
  3 arguments: Paths to the source image, the watermark image, and the
  destination image. The default command is C<photog-watermark> which
  places the watermark file in the lower-right corner.
  
  =cut
  
      $album->{watermark_command} ||= $parent->{watermark_command}
                                  || 'photog-watermark';
  
  =item B<thumbnail_command>
  
  The path to a command that generates image thumbnails. The command
  receives 2 arguments: The source image path and the thumbnail
  destination path. The default is C<photog-thumbnail>, which performs
  quite a bit of sharpening to make sure that the thumbnail doesn't
  become blurry after resizing.
  
  =cut
  
      $album->{thumbnail_command} ||= $parent->{thumbnail_command}
                                  || 'photog-thumbnail';
  
  =item B<preview_command>
  
  The command that generates album previews by compositing multiple
  thumbnails together. It will receive paths to the source images'
  thumbnails as its arguments, and the path to a destination file as its
  final argument. Currently, Photog! will only request previews of 3, 6,
  or 9 images.
  
  =cut
  
      $album->{preview_command} ||= $parent->{preview_command}
                                || 'photog-preview';
  
  =back
  
  =cut
  
      # Finally, inherit all remaining parent values
      for (keys %$parent) {
          next if $_ eq 'items';
          next if exists $album->{$_};
          $album->{$_} = $parent->{$_};
      }
  
      return $album;
  }
  
  sub get_config {
      my $directory = shift;
      my $file = catfile($directory, $CONFIG_FILE);
      if (-f $file) {
          return { ParseConfig(-ConfigFile=>$file, -AutoTrue=>1) };
      }
      else {
          return 0;
      }
  }
  
  sub save_config {
      my $config = shift;
      my $directory = shift;
      my $file = catfile($directory ,$CONFIG_FILE);
      open(my $fh, '>', $file)
          or die "ERROR: Can't open '$file' for writing\n";
      for my $key (keys %{$config}) {
          say $fh "$key = $config->{$key}";
      }
  }
  
  sub is_image {
      return shift =~ /\.jpg$/;
  }
  
  sub strip_suffix {
      my $file = shift;
      $file =~ s/\.[^\.]+$//;
      return $file;
  }
  
  =head1 SEE ALSO
  
  photog(3), Photography::Website(1)
  
  =head1 AUTHOR
  
  Photog! was written by Jaap Joris Vens <jj@rtts.eu>, and is used to
  create his personal photography website at http://www.superformosa.nl/
  
  =cut
  
  1;
PHOTOGRAPHY_WEBSITE_CONFIGURE

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

use warnings;
use strict;
use feature 'say';
use Cwd;
use IPC::Cmd 'can_run';
use Photography::Website;

die <<EOM

ERROR: ImageMagick is not installed. Please install it in order to use
Photog!, preferably using your operating system's package manager. Try
one of the following commands:

    apt-get install imagemagick
    yum install ImageMagick
    pacman -S imagemagick
    brew install imagemagick

EOM
    unless can_run('convert') and can_run('composite');

=head1 NAME

Photog! - The Photography Website Generator

=head1 SYNOPSIS

B<photog> [I<-q>] [I<-v>] [I<destination>]

B<photog->[B<scale>, B<watermark>, B<thumbnail>, B<preview>]

=head1 DESCRIPTION

Photog! turns a directory tree of source images into a photography
website with nested albums of chronologically sorted photographs. To
get started, simply C<cd> to the source directory and call C<photog>
with the destination directory as its argument. Example:

    $ cd ~/Pictures
    $ photog ~/public_html

Upon the first run, Photog! writes the website destination to the file
C<photog.ini> inside the current directory. Subsequent runs of the
C<photog> command require no arguments, and do nothing unless images
inside the source directory tree have changed. Photog! only
regenerates the parts of the website that should be updated.

=head1 OPTIONS

=over

=item B<-q>

Be less verbose

=item B<-v>

Be more verbose

=back

=head1 CONFIGURATION

Photog! reads configuration directives from a file named C<photog.ini>
inside the source directory. Subdirectories can contain additional
configuration files that override certain settings from the root
configuration file. A value set in the configuration file will become
the new default value for all child albums.

Config files consist of a number of C<variable = value>
directives. Empty lines and lines starting with a C<#> are
ignored. All the possible configuration variables are documented in
the manual page of Photography::Website::Configure(3), the module that
implements Photog!'s configuration system. Here is an example
configuration file:

    # This is an example ~/Pictures/photog.ini
    title = Super Formosa Photography
    watermark = /home/jj/watermark.png
    template = /home/jj/frontpage-template.html
    destination = /var/www/superformosa.nl

This tells Photog! the title, watermark, template, and destination to
use when generating the album that corresponds to the directory
C<~/Pictures>. The albums that are created from the subdirectories
inside C<~/Pictures> will also have the same title, watermark,
template and destination, because these values are inherited by all
child albums (unless they are overridden by additional C<photog.ini>
files). Again, for a complete list of all possible configuration
variables consult the Photography::Website::Configure(3) manual page.

=head1 TEMPLATING

Photog! comes with a file named C<template.html> that uses
Template::Toolkit syntax to render each album's C<index.html>. The
default template uses Javascript to "pack" images into horizontal
rows. You can supply the path to your own template with the
B<template> configuration variable.

All the configuration options automatically become template
variables. An additional template variable, B<items>, contains the
sorted list of the album's children. Here is an example template (see
Template::Manual::Intro(3) for an introduction to the template
syntax):

    <h1>Welcome to [% title %]!</h1>
    <p>These are my photo albums:</p>
    [% FOREACH item in items %]
      [% IF item.type == 'album' %]
        <img src="[% item.src %]" title="[% item.my_custom_title %]">
      [% ENDIF %]
    [% ENDFOR %]

As you can see, this example references the attribute
C<my_custom_title> of each child album. This is not an "official"
configuration option, but as long as you set it yourself in the
album's C<photog.ini> it will be available to all child albums just
like the regular configuration variables.

=head1 ADDITIONAL COMMANDS

Photog! calls the commands C<photog-scale>, C<photog-watermark>,
C<photog-thumbnail>, and C<photog-preview> to generate scaled,
watermarked, thumbnail and preview images. These commands are simple
shell scripts that have been installed to the same path as the
C<photog> command. They call ImageMagick to do the actual image
processing. You can also call these commands directly. Each command
prints out a simple usage instruction when called with no
arguments. If you want to change Photog!'s behavior for generating
images and thumbnails, you can supply your own commands in the
configuration file (see Photography::Website::Configure(3)).

=head1 SEE ALSO

Photography::Website(3), Photography::Website::Configure(3)

=head1 AUTHOR

Photog! was written by Jaap Joris Vens <jj@rtts.eu>, and is used to create
his personal photography website at http://www.superformosa.nl/

=cut

######################################################################

my $source = getcwd();
my $destination;

# Process arguments
for (@ARGV) {
    if ($_ eq '-v') {
        $Photography::Website::verbose = 1;
    }
    elsif ($_ eq '-q') {
        $Photography::Website::silent = 1;
    }
    elsif (not defined $destination) {
        $destination = $_;
    }
    else {
        die "Too many command-line arguments\n";
    }
}

# Create a fresh photog.ini
if (not -f "$source/photog.ini") {
    if ($destination) {
        open(my $fh, '>', "$source/photog.ini");
        print $fh "destination = $destination\n";
        close $fh;
    }
    else {
        die <<EOM

ERROR: No destination specified. Please specifiy a destination for
your photography website. You can do this either as a command-line
argument or in the configuration file 'photog.ini'. See 'man photog'
for more information.

EOM
            ;
    }
}

# Process the pictures tree
my $website = Photography::Website::create_album($source);

# Generate the website
Photography::Website::generate($website);
